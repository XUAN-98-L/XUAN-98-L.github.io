<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>local_git</title>
    <link href="/2024/10/16/local-git/"/>
    <url>/2024/10/16/local-git/</url>
    
    <content type="html"><![CDATA[<p>git 本地版本管理</p><span id="more"></span><h1 id="详细教程"><a href="#详细教程" class="headerlink" title="详细教程"></a><a href="https://zhangping.gitbooks.io/projectprepare/content/git/gitben_di_ban_ben_guan_li.html">详细教程</a></h1><h1 id="初始化一个本地仓库"><a href="#初始化一个本地仓库" class="headerlink" title="初始化一个本地仓库"></a>初始化一个本地仓库</h1><p>cd 到保存仓库的路径<br>使用git init创建本地仓库</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> init<br><span class="hljs-comment"># 当出现 &quot;Initialized empty Git repository in 文件夹名&quot; 时，初始化已成功</span><br></code></pre></td></tr></table></figure><p><img src="/2024/10/16/local-git/image-20241016220312841.png"></p><h1 id="给仓库配置用户名和用户邮箱"><a href="#给仓库配置用户名和用户邮箱" class="headerlink" title="给仓库配置用户名和用户邮箱"></a>给仓库配置用户名和用户邮箱</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 配置用户名</span><br>git config <span class="hljs-keyword">user</span>.name gloria<br><span class="hljs-comment"># 配置邮箱</span><br>git config <span class="hljs-keyword">user</span>.email xxxxxxx@hotmail.com<br><span class="hljs-comment"># 配置全局用户名和全局邮箱</span><br>git config --global <span class="hljs-keyword">user</span>.name gloria<br>git config --global <span class="hljs-keyword">user</span>.email xxxxxxx@hotmail.com<br><br><span class="hljs-comment"># 查看是否配置完成</span><br>git config <span class="hljs-keyword">user</span>.name<br>git config <span class="hljs-keyword">user</span>.email<br><span class="hljs-comment"># 配置全局的 user.name 和 user.email 会保存在 /Users/UserName/.gitconfig 文件中</span><br></code></pre></td></tr></table></figure><h1 id="添加或修改文件"><a href="#添加或修改文件" class="headerlink" title="添加或修改文件"></a>添加或修改文件</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 查看当前仓库的状态(可以查看哪些文件没有被添加到仓库，哪些文件被修改了)</span><br><span class="hljs-attribute">git</span> status<br><br><span class="hljs-comment"># Untracked files 表示没有添加到仓库的文件</span><br><span class="hljs-comment"># modified 文件被修改</span><br><span class="hljs-comment"># Changes to be committed 需要提交到仓库</span><br></code></pre></td></tr></table></figure><h1 id="将文件提交到仓库"><a href="#将文件提交到仓库" class="headerlink" title="将文件提交到仓库"></a>将文件提交到仓库</h1><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 将文件添加到 暂存区</span><br><span class="hljs-comment"># 添加单个文件</span><br>git <span class="hljs-built_in">add</span> 文件名<br><span class="hljs-comment"># 添加当前目录下的整个文件夹</span><br>git <span class="hljs-built_in">add</span> .<br><br><span class="hljs-comment"># 将文件添加到 对象存储区（仓库）</span><br>git commit -m <span class="hljs-string">&quot;本次对xxx进行了修改&quot;</span><br></code></pre></td></tr></table></figure><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 查看版本库的提交日志</span><br>git <span class="hljs-built_in">log</span><br><span class="hljs-comment"># 如果内容过多，可使用 空格键 下一页，Control + b 上一页，使用 j 下一行，使用 k 上一行</span><br><br><span class="hljs-comment"># 将仓库和工作目录代码回退到指定版本</span><br>git reset <span class="hljs-comment">--hard 版本号</span><br><span class="hljs-comment"># 例如</span><br>git reset <span class="hljs-comment">--hard 6af39d74db55da5b5fd60fb8f4ad6baab29ba801</span><br></code></pre></td></tr></table></figure><p><img src="/2024/10/16/local-git/image-20241016223701670.png"></p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 如果对刚刚的回退操作不满意，可以查看之前的版本号</span><br>git reflog<br><span class="hljs-comment"># 然后使用reset再次会退到之前的版本号</span><br><span class="hljs-comment"># 例如</span><br>git reset <span class="hljs-comment">--hard aa6523c</span><br></code></pre></td></tr></table></figure><p><img src="/2024/10/16/local-git/image-20241016221846140.png"></p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 修改文件后可以使用diff查看文件改变</span><br>git <span class="hljs-keyword">diff</span><br><span class="hljs-keyword"></span><span class="hljs-comment"># + 表示添加了内容</span><br><span class="hljs-comment"># - 表示减少了内容</span><br><br><span class="hljs-comment">#将指定文件的修改撤销</span><br>git checkout 文件名<br></code></pre></td></tr></table></figure><p><img src="/2024/10/16/local-git/image-20241016222151629.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 忽略不想添加到仓库的文件</span><br><span class="hljs-comment"># 在开发过程中，有些文件我们不想提交到git仓库，需要将不想添加到git仓库的文件写入.gitignore文件</span><br><span class="hljs-built_in">touch</span> .gitignore<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git init    <span class="hljs-comment"># 创建本地仓库</span><br>git config <span class="hljs-keyword">user</span>.name yourname   <span class="hljs-comment"># 配置用户名</span><br>git config <span class="hljs-keyword">user</span>.email youremail <span class="hljs-comment"># 配置用户邮箱</span><br>git config --global <span class="hljs-keyword">user</span>.name yourname      <span class="hljs-comment"># 配置全局的用户名</span><br>git config --global <span class="hljs-keyword">user</span>.email youremail    <span class="hljs-comment"># 配置全局的用户邮箱</span><br>git status       <span class="hljs-comment"># 查看仓库的状态</span><br>git <span class="hljs-keyword">add</span><span class="language-bash"> 文件名  <span class="hljs-comment"># 将文件添加到暂存区</span></span><br>git <span class="hljs-keyword">add</span><span class="language-bash"> .       <span class="hljs-comment"># 将当前目录的所有文件添加到暂存区</span></span><br>git commit      <span class="hljs-comment"># 将文件添加到 对象存储区(仓库)</span><br>git log         <span class="hljs-comment"># 查看版本库的提交日志</span><br>git reset --hard 版本号: <span class="hljs-comment"># 将仓库和工作目录代码回退到指定版本</span><br>git reflog      <span class="hljs-comment"># 可以看到每次的提交操作</span><br>git checkout 文件名 <span class="hljs-comment"># 将这个文件的的修改撤销</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Proteomics</title>
    <link href="/2024/08/20/Proteomics/"/>
    <url>/2024/08/20/Proteomics/</url>
    
    <content type="html"><![CDATA[<p>Proteomics info collection</p><span id="more"></span><h1 id="Bottom-up-proteomics"><a href="#Bottom-up-proteomics" class="headerlink" title="Bottom-up proteomics"></a>Bottom-up proteomics</h1><p>The system-wide characterization of the proteome using mass spectrometry (MS), and more specifically on bottom-up proteomics where proteins are digested into smaller pieces called peptides, which are analysed by MS.</p><p>MS-based proteomics can analyse the protein content of any material. Apart from mainstream sources such as cell lines, this encompasses clinically important, archived formalin-fixed paraffin-embedded (FFPE) biopsy tissues and even fossils that are hundreds of thousands of years old.</p><h2 id="Data-acquisition"><a href="#Data-acquisition" class="headerlink" title="Data acquisition"></a>Data acquisition</h2><h3 id="DDA-and-DIA-are-the-common-data-acquisition-strategies-in-shotgun-proteomics-how-to-select-picks-from-MS1-spectrum"><a href="#DDA-and-DIA-are-the-common-data-acquisition-strategies-in-shotgun-proteomics-how-to-select-picks-from-MS1-spectrum" class="headerlink" title="DDA and DIA are the common data acquisition strategies in shotgun proteomics.(how to select picks from MS1 spectrum)"></a><a href="https://portlandpress.com/biochemist/article/42/5/64/226371/A-beginner-s-guide-to-mass-spectrometry-based">DDA and DIA are the common data acquisition strategies in shotgun proteomics.</a>(how to select picks from MS1 spectrum)</h3><ul><li><strong>data-dependent acquisition (DDA),</strong> meaning that the mass spectrometer follows <strong>a set of user-defined rules (such as m&#x2F;z, charge, intensity and cross-section)</strong> to select as many peptides as possible for acquiring MS&#x2F;MS spectra. However, this selection is partly stochastic as there are more peptides than analysis time, and it <strong>generates missing values</strong>. </li><li>In <strong>data-independent acquisition (DIA)</strong> methods, the quadrupole instead continuously cycles across <strong>the entire mass range while selecting relatively large m&#x2F;z values (20–40 m&#x2F;z)</strong>. This leads to very complex MS&#x2F;MS spectra since they contain the superimposed fragmentation patterns from co-isolated peptide ions. Modern software can deconvolute the spectra to identify the multiple peptides, usually by comparison to a previously acquired ‘peptide library’, but increasingly also without.<br><img src="/2024/08/20/Proteomics/image-20240820133755140.png"></li></ul><h2 id="Quantification-strategies-for-peptides"><a href="#Quantification-strategies-for-peptides" class="headerlink" title="Quantification strategies for peptides"></a>Quantification strategies for peptides</h2><ul><li><strong>Label-free quantification (LFQ):</strong> the MS signals of the peptides (usually at the MS1 level) are extracted from the raw data, normalised and compared between the proteomic conditions of interest. It is experimentally the most straightforward and usually the most economical approach, providing great flexibility in project design. However, this strategy has <strong>higher quantification variance</strong>, and differences in peptide purity and instrument performance may impact comparisons between individual samples if sufficient care is not taken.<br>  <a href="https://www.mcponline.org/article/S1535-9476(20)33310-7/fulltext">Accurate Proteome-wide Label-free Quantification by Delayed Normalization and Maximal Peptide Ratio Extraction, Termed MaxLFQ</a><br>  The MaxLFQ algorithm is integrated into MaxQuant and it is initially developed for DDA (and also can be used for DIA).<br>  <a href="https://www.sciencedirect.com/science/article/pii/S1535947623000920#bib26">One reason for the popularity of MaxLFQ</a> is that it addresses major pitfalls in proteomics quantification by accounting for the fact that different peptides belonging to the same protein can have very different base intensities, for example, due to differing ionization efficiencies. In addition, it is robust against missing values for normalization (differing sample depths) and can reliably estimate protein intensities.</li><li><strong>label based:</strong> Label-based approaches use stable isotopes to encode different proteome states – the beauty is that the resulting peptides have exactly the same physiochemical behaviour, but have predictable differences in mass. The isotopes can be metabolically introduced, which also allows determination of protein turnover; however, chemical labelling with ‘readout’ at the MS&#x2F;MS level is now much more common. The latter is referred to as isobaric labelling and involves a clever trick in which the mass of the tag remains the same, but the distribution of isotopes in the tag is revealed after fragmentation. Within a set of 6–16 different tags, quantification variance is typically lower than in LFQ if samples are consistently and reproducibly labelled and combined. A major caveat of the typically used TMT (tandem mass tag) isobaric labelling method is that co-fragmented peptides can suppress quantitative differences (‘ratio compression’). <strong>iTRAQ (Isobaric Tags for Relative and Absolute Quantitation) and TMT (Tandem Mass Tags)</strong> are two widely used peptide labeling techniques for quantitative proteomics.</li></ul><h1 id="tools-for-DDA-LFQ-analysis"><a href="#tools-for-DDA-LFQ-analysis" class="headerlink" title="tools for DDA LFQ analysis"></a>tools for DDA LFQ analysis</h1><ol><li><a href="https://github.com/MonashBioinformaticsPlatform/LFQ-Analyst/tree/master">LFQ-Analyst</a>This is a software that supports Label-Free Proteomics Data Preprocessed with MaxQuant.</li></ol><h1 id="Normalisation-methods"><a href="#Normalisation-methods" class="headerlink" title="Normalisation methods"></a>Normalisation methods</h1><ol><li>vsn: Huber W, Von Heydebreck A, Sültmann H, Poustka A, Vingron M. Variance stabilization applied to microarray data calibration and to the quantification of differential expression. Bioinformatics. 2002 Jul 1;18(suppl_1):S96–104.</li></ol><h1 id="MaxQuant-summer-school"><a href="#MaxQuant-summer-school" class="headerlink" title="MaxQuant summer school"></a><a href="https://www.youtube.com/watch?v=xfKS7h_eZIo&list=PL6yHRLjecpwAMJhXVCXFk9sso-MNhL7GX">MaxQuant summer school</a></h1>]]></content>
    
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo迁移(win2mac)</title>
    <link href="/2024/05/27/hexo%E8%BF%81%E7%A7%BB/"/>
    <url>/2024/05/27/hexo%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p>hexo迁移到mac电脑</p><span id="more"></span><h1 id="使用安装教程为mac安装homebrew："><a href="#使用安装教程为mac安装homebrew：" class="headerlink" title="使用安装教程为mac安装homebrew："></a>使用<a href="https://www.digitalocean.com/community/tutorials/how-to-install-and-use-homebrew-on-macos">安装教程</a>为mac安装homebrew：</h1><p>注意添加brew到系统路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br>(<span class="hljs-built_in">echo</span>; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;&#x27;</span>) &gt;&gt; /Users/gloria/.zprofile<br><br><span class="hljs-built_in">eval</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(/opt/homebrew/bin/brew shellenv)</span></span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h1 id="安装node-js和git"><a href="#安装node-js和git" class="headerlink" title="安装node.js和git"></a>安装node.js和git</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>brew install node.js<br><br>brew install git<br><br></code></pre></td></tr></table></figure><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>npm install -g hexo-cli<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装 hexo-deployer-git</span><br>npm install hexo-deployer-git --save<br><br></code></pre></td></tr></table></figure><h1 id="从git上将过往博客clone到本地"><a href="#从git上将过往博客clone到本地" class="headerlink" title="从git上将过往博客clone到本地"></a>从git上将过往博客clone到本地</h1><ul><li><p>在原来的电脑上创建hexo分支，并将全部文件夹都上传上去</p></li><li><p>在新电脑上配置<a href="https://docs.github.com/en/authentication/connecting-to-github-with-ssh/checking-for-existing-ssh-keys">git ssh</a></p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">将hexo分支克隆到本地（注意克隆的时候一定要选择ssh而不是https）</span><br>git clone -b hexo git@github.com:XUAN-98-L/XUAN-98-L.github.io.git hexo<br></code></pre></td></tr></table></figure><h1 id="hexo初始化"><a href="#hexo初始化" class="headerlink" title="hexo初始化"></a>hexo初始化</h1><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-meta">#需要进入到hexo文件夹内</span><br>npm install hexo --save<br><br><span class="hljs-meta">#修改_config.yml中deploy的部分，将其从https改为ssh</span><br><span class="hljs-symbol">deploy:</span><br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:XUAN<span class="hljs-number">-98</span>-L/XUAN<span class="hljs-number">-98</span>-L.github.io.git<br></code></pre></td></tr></table></figure><h1 id="obsidian-和hexo连用"><a href="#obsidian-和hexo连用" class="headerlink" title="obsidian 和hexo连用"></a>obsidian 和hexo连用</h1><p><a href="https://itreefly.com/posts/e5113722.html">https://itreefly.com/posts/e5113722.html</a></p><p>obsidian将“文件与链接”中“使用wiki链接“关闭</p><p>使用obsidian打开_posts作为仓库，并安装Custom Attachment Location插件<br>设置Location for new attachment为：<br>.&#x2F;${filename}<br>并将rename attachment files打开</p><h1 id="将修改后的文件推送到git"><a href="#将修改后的文件推送到git" class="headerlink" title="将修改后的文件推送到git"></a>将修改后的文件推送到git</h1><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">git <span class="hljs-keyword">add</span> .<br>git commit -m “提交消息”<br>git <span class="hljs-keyword">push</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diversity指数学习笔记</title>
    <link href="/2024/05/27/diversity/"/>
    <url>/2024/05/27/diversity/</url>
    
    <content type="html"><![CDATA[<p>Diversity指数学习笔记</p><span id="more"></span><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>假设：我们手中有肿瘤样本在某药物<strong>治疗前</strong>和<strong>治疗后</strong>的配对TCR数据，想比较药物对患者治疗前后的CDR3多样性的影响。我们需要考虑的的问题有以下两个：</p><ul><li>衡量治疗前和治疗后，<strong>对于相同样本</strong>，CDR3序列多样性（CDR3 repertoire）变化程度如何？是有很大差异，还是该药物没有对CDR3多样性造成影响？<br>  Alpha diversity（别名within sample diversity）</li><li><strong>不同样本之间</strong>CDR3是相似，还是差距很大？<br>  Beta diversity</li></ul><h1 id="Alpha-diversity"><a href="#Alpha-diversity" class="headerlink" title="Alpha diversity"></a><a href="https://www.youtube.com/watch?v=tucm8y5xi88">Alpha diversity</a></h1><p><img src="/2024/05/27/diversity/image-20240518171232875.png"><br>如上图：两个花园里花的种类一样丰富吗？<br>对于Alpha多样性，常用的指标&#x2F;指数是<a href="https://mibwurrepo.github.io/Microbial-bioinformatics-introductory-course-Material-2018/alpha-diversities.html">Shannon, Inverse Simpson, Simpson, Gini, Observed and Chao1。</a></p><p>这些指标一般由两个部分的度量组成：<br>用于衡量样本内有多少种unique CDR3数量的指标：<strong>丰富度（richness）</strong>。（每种CDR3是否存在，如下图，用1或0表示）<br>用于衡量样本内每种CDR3分布频率的指标：<strong>均匀度（evenness）</strong>。<br><img src="/2024/05/27/diversity/image-20240518171304821.png"></p><p>观察下面的两个树群：树群1和树群2的richness相同，但evenness不同。树群1的树种类分布要更加均衡，而树群2的diversity要更高。<br>高Evenness（范围为 0 到 1）意味着所有元素几乎均匀分布，而低均匀度则表明向某一群体偏斜。从下图可以看出，树群2的第三种树占据了70%的比例，因此树群2的evenness要更低，树群1的evenness更高。<br><img src="/2024/05/27/diversity/image-20240518171325965.png"></p><h2 id="Shannon-entropy"><a href="#Shannon-entropy" class="headerlink" title="Shannon entropy"></a>Shannon entropy</h2><p><strong>Shannon entropy <a href="https://linkinghub.elsevier.com/retrieve/pii/S0092867417311224">此指标同时考虑 richness和evenness， 但是更重视evenness</a>。该指数越高，说明样本中克隆的diversity越高。</strong></p><p>根据<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7571402/">下图</a>展示的公式，我们需要如下信息来计算香农熵：</p><ol><li>CDR3的总数：n</li><li>每种CDR3的频率：pi （一般我们是通过CDR3 counts来计算的）<br><img src="/2024/05/27/diversity/image-20240518171357026.png"></li></ol><p>按照公式对上面的树木分布计算香农熵，Community 1的值是1.39，Community 2的值是1.06。(由于树群1和树群2的richness相同，但树群1的evenness更高，所以树群1的shannon entropy要更高。)</p><p>在实现上可以使用immunarch的<a href="https://immunarch.com/reference/entropy.html">entropy函数</a>，为每个sample计算对应的shannon entropy<br>源码见：<br><a href="https://github.com/immunomind/immunarch/blob/HEAD/R/info_theory.R">https://github.com/immunomind/immunarch/blob/HEAD/R/info_theory.R</a></p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel">assay_metadata = data.table::<span class="hljs-keyword">fread</span>(metadata,header =T )<br>assay_metadata = assay_metadata %&gt;% <span class="hljs-keyword">rename</span>(Sample = sampleid ) %&gt;% as.data.frame()<br>rownames(assay_metadata) = assay_metadata$Sample<br><br>immdata = list() #an empty immdata list<br><br>vdj_profile = Sys.glob(<span class="hljs-keyword">file</span>.path(input_path,assay_metadata$Sample,<span class="hljs-string">&quot;outs&quot;</span>,<span class="hljs-string">&quot;per_sample_outs&quot;</span>,assay_metadata$Sample,type_path,<span class="hljs-string">&quot;filtered_contig_annotations.csv&quot;</span>))<br><br>immdata$data = repLoad(vdj_profile, .<span class="hljs-keyword">format</span> = <span class="hljs-string">&quot;10x&quot;</span>)<br><br>#针对样本<span class="hljs-number">1</span>进行测试，需要筛选只对Proportion进行计算<br>test = immdata$data[[<span class="hljs-number">1</span>]] %&gt;% as.data.frame() %&gt;% <span class="hljs-keyword">select</span>(Proportion)<br>#注意将base改为e<br>entropy(test, .base = <span class="hljs-keyword">exp</span>(<span class="hljs-number">1</span>), .norm = FALSE, .<span class="hljs-keyword">do</span>.norm = NA, .laplace = <span class="hljs-number">1e-12</span>)<br></code></pre></td></tr></table></figure><h2 id="Simpson’s-Diversity-Index"><a href="#Simpson’s-Diversity-Index" class="headerlink" title="Simpson’s Diversity Index"></a><strong>Simpson’s Diversity Index</strong></h2><p><strong>Simpson index同时考虑Richness和Evenness</strong></p><p><a href="https://www.nature.com/articles/163688a0">公式</a>如下：<br><img src="/2024/05/27/diversity/image-20240518171432780.png"></p><p>我们通常不直接用Simpson index（D）,它反映的是在同一个样本中随机的抽取2个个体，这两个个体来自同一个类的概率（以TCR为例，辛普森指数是从样本中随机选择的任意两个tcr具有不同克隆型的概率。）。故D值越大，多样性越低。这与直觉和逻辑不符。</p><p>为了解决这个问题，通常会用以下两种形式来表示：<br>（1）1-D，即Gini-Simpson Diversity index<br>Gini-Simpson多样性指数表示在克隆群中随机选取两个克隆序列，两者属于不同种类克隆的概率。Gini-Simpson值越高，代表克隆的多样性越高。公式中，ni为第i个特异性克隆类型的氨基酸序列的总数，N为样本中总的序列数。（<strong>使用时有些地方也会将Gini-Simpson简化成Simpson，实际上这里是指Gini-Simpson，可根据公式区分</strong>，比如此处就直接缩写为simpson了：<a href="https://geographyfieldwork.com/Simpson'sDiversityIndex.htm#:~:text=Simpson's%20Diversity%20Index%20is%20a,evenness%20increase%2C%20so%20diversity%20increases.&text=The%20value%20of%20D%20ranges%20between%200%20and%201.">示例</a>）</p><p><img src="/2024/05/27/diversity/image-20240518171459152.png"><br>可使用immunarch直接计算<br>div_div &lt;- repDiversity(immdata$data, “gini.simp”)</p><p> <strong>数值接近0 表示没有多样性（即高度寡克隆），数值接近1就是diversity接近无穷（polyclonal repertoire with equivalent representation of each clone）</strong></p><p>（2）1&#x2F;D，即Inverse-Simpson index<br>可使用immunarch直接计算<br>div_div &lt;- repDiversity(immdata$data, “inv.simp”)<br>逆辛普森多样性指数是辛普森指数的倒数，逆辛普森指数越大，表示克隆的多样性越高。侧重于反映高频克隆的多样性。</p><h2 id="Hill-numbers"><a href="#Hill-numbers" class="headerlink" title="Hill numbers"></a>Hill numbers</h2><p><a href="https://www.sciencedirect.com/science/article/pii/S0958166920301051?via=ihub">Hill number， 也叫effective numbers of species，有效物种数，通过它可以看出来数据集中不同克隆型的有效数量 (i.e. number of equally abundant sequences producing the given value of diversity)。</a></p><p>hill number是一个比较广义的度量，公式如下：<br><img src="/2024/05/27/diversity/image-20240518171517523.png"><br>如下图，可以看到横坐标是Q value。hill number量化了diversity。丰度分布的重要性随着希尔阶数（Q，也就是公式中的alpha，即阶数）的增加而增加。对于 Q&#x3D;0，希尔数是richness；对于 Q &#x3D;1，它其实就是Shannon entropy，就可以解释为常见或较丰富CDR3序列的有效数量 ；对于 q&#x3D;2，它是inverse Simpson index，可以解释为优势或高度丰富CDR3的有效数量。<br>因此，hill number就是比较在同样的diversity下，CDR3序列的数量在哪个样本中更高。<br><img src="/2024/05/27/diversity/image-20240518171539041.png"></p><h2 id="Diversity-evenness-50-DE50"><a href="#Diversity-evenness-50-DE50" class="headerlink" title="Diversity evenness 50 (DE50)"></a>Diversity evenness 50 (DE50)</h2><p><strong>此指标仅考虑Evenness。</strong><br>DE50值越高，代表各克隆分布比较均匀，DE50值越低，克隆性越高，代表有一些特异性的克隆发生了扩增(这种特异性克隆扩增的情况可以形容为“更具寡克隆性”，oligoclonal）。<br><img src="/2024/05/27/diversity/image-20240518171552117.png"></p><p>公式的计算方法为：将克隆序列按照频率从高到低排序，从最高开始累加，达到频率总和为50%的这些序列的克隆种类占总克隆种类的比例。（<a href="https://www.nature.com/articles/s41598-018-19548-y">Diversity Evenness 50 (DE50) was calculated as the ratio of how many clonotypes amongst the most frequent were necessary to account for 50% of the total read counts divided by the total number of read counts present.</a>）</p><p>此指标在immunarch中也叫D50，用repDiversity函数计算：<br>d50 is a recently developed immune diversity estimate. It calculates the minimum number of distinct clonotypes amounting to greater than or equal to 50 percent of a total of sequencing reads obtained following amplification and sequencing<br><img src="/2024/05/27/diversity/image-20240518171603029.png"></p><h2 id="Pielou’s-index"><a href="#Pielou’s-index" class="headerlink" title="Pielou’s index"></a><em>Pielou’s</em> index</h2><p><strong>与D50一样，此指标仅考虑Evenness。</strong><br>Pielou 指数是衡量物种在群落中分布均匀程度的一种方法。 Pielou 指数值定义在 0 到 1 之间。1 代表具有完美均匀度的群落，随着物种的相对丰度偏离均匀度，该指数会降至零。<br>In parallel to DE50, clonal evenness of a repertoire can be calculated using Pielou’s index, which is itself derived from the ratio between the Shannon entropy and the maximization of the diversity distribution of species within a sample</p><p>Pielou 指数是基于 Shannon entropy计算 ，使用 Shannon entropy 除以样本内的总克隆型的数量（N），计算公式如下：<br><img src="/2024/05/27/diversity/image-20240518171615623.png"></p><p>与Pielous指数相关的另一个概念是<a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7571402/">“<strong>Clonality</strong>”</a>，克隆性:<br>计算Clonality可以使用1-Pielou 指数。<br>该数值越接近0，evenness越高；数值越接近1，即存在优势克隆（clonal dominance）,少数克隆出现在较高频率。<br>计算公式如下：<br><img src="/2024/05/27/diversity/image-20240518171628900.png"></p><p><a href="https://www.tandfonline.com/doi/full/10.1080/2162402X.2019.1652538">典型文献</a>是在对接受PD-1免疫治疗药物治疗的转移性黑色素瘤患者的外周和肿瘤 T 细胞克隆性时，强调了以 1-Pielou 指数为代表的克隆扩张与临床反应之间的关联。实验结果显示，在药物治疗后出现更高的克隆性的患者，具有更长的生存时间。</p><h2 id="Gini-coefficient"><a href="#Gini-coefficient" class="headerlink" title="Gini coefficient"></a>Gini coefficient</h2><p><strong>此指标仅考虑Evenness。</strong><br><strong>注意gini coefficient（基尼系数） 与 Gini-Simpson不是同样的概念。</strong><br>与上面提到的Pielou 指数类似，gini coefficient也可以用作clonality的度量<br><strong>基尼系数的范围从 0（CDR3 repertoire的最大多样性,即每个序列的丰度相等) 到 1(即极端不平等, 出现对单个CDR3序列的高克隆性)</strong></p><h2 id="Chao1"><a href="#Chao1" class="headerlink" title="Chao1"></a>Chao1</h2><p><strong>此指标仅考虑Richness。</strong><br>用来反应 clonotypes 的丰度，对稀有的物种很敏感。<br>Chao1 指数越高，clonotypes Richness越高，多样性越高。<br>受到Sample size的影响较大，在high diverse的群体中不准确，因此一般不单独使用，都是和其余指标联合使用。<br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4528489/">多指数评估文献1</a><br><a href="https://www.frontiersin.org/journals/immunology/articles/10.3389/fimmu.2022.1006136/full">典型文献</a></p><h1 id="Beta-diversity"><a href="#Beta-diversity" class="headerlink" title="Beta diversity"></a>Beta diversity</h1><p><img src="/2024/05/27/diversity/image-20240518171643644.png"></p><p>如上图：两个花园里是否有相同的花？<br>β -多样性:衡量不同群体样本之间的差异，以确定整体群落组成和结构是否存在差异。</p><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><h2 id="Jensen-Shannon-divergence"><a href="#Jensen-Shannon-divergence" class="headerlink" title="Jensen-Shannon divergence"></a>Jensen-Shannon divergence</h2><p>白板推导教程参考：<br><a href="https://www.youtube.com/watch?v=bqjZK9tkWdk">https://www.youtube.com/watch?v=bqjZK9tkWdk</a></p><p>除了对每个样本进行的diversity分析之外，TCR&#x2F;BCR 测序数据还需要进行相似性分析，以便比较 T-cell repertoires之间的重叠。JSD指数就是一个反应相似性的指数，**<a href="https://doi.org/10.1016/j.xcrm.2020.100141">JSD越低，repertoire stability越高</a>，也就是说两个CDR3氨基酸频率分布的差异越小（也可以说<a href="https://journals.aai.org/jimmunol/article/209/2/238/234249/Analysis-of-Gene-Expression-and-TCR-B-Cell">V和J段的分布更相似</a>。)**</p><p><a href="https://linkinghub.elsevier.com/retrieve/pii/S2666379120301853">示例一</a>：<br><img src="/2024/05/27/diversity/image-20240518171700855.png"></p><p>上面的例图展示了 PFS-9患者(药物治疗后疗效更好的患者组) 和 非PFS-9患者（药物治疗疗效较差的患者组） <strong>疫苗注射前(左)</strong> 或 <strong>疫苗注射后(右)</strong> 与基线(Pre-treatment)之间的TCRb CDR3序列的JSD值。如左侧箭头所示，低JSD值表示repertoire stability。黑线为中位数。p值来自双尾Student ‘s t检验。<br>本图使用<a href="https://github.com/drostlab/philentropy">philentropy包</a>实现,此包可以实现两组比较的效果（由于JSD的对称特性，比较组不分先后）</p><p><a href="https://journals.aai.org/jimmunol/article/209/2/238/234249/Analysis-of-Gene-Expression-and-TCR-B-Cell">示例二</a>：<br><img src="/2024/05/27/diversity/image-20240518171714329.png"></p><p>本图使用immunarch实现（immunarch对所有输入的样本进行成对检验，出具热图）：<br><a href="https://immunarch.com/articles/web_only/v5_gene_usage.html?q=divergence#gene-usage-analysis">https://immunarch.com/articles/web_only/v5_gene_usage.html?q=divergence#gene-usage-analysis</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CytoTRACE文献阅读</title>
    <link href="/2023/12/22/CytoTRACE/"/>
    <url>/2023/12/22/CytoTRACE/</url>
    
    <content type="html"><![CDATA[<p>CytoTRACE的文献笔记</p><span id="more"></span><h2 id="基础信息"><a href="#基础信息" class="headerlink" title="基础信息"></a><a href="https://www.science.org/doi/10.1126/science.aax0249?url_ver=Z39.88-2003&rfr_id=ori:rid:crossref.org&rfr_dat=cr_pub%20%200pubmed">基础信息</a></h2><ul><li><strong>Title</strong>:<br>Single-cell transcriptional diversity is a hallmark of developmental potential</li><li><strong>Author</strong>: Gunsagar S. Gulati1</li><li><strong>Year</strong>: 2020</li><li><strong>Journal</strong>: Science</li><li><strong>IF</strong>: 56.9</li></ul><h2 id="研究主题"><a href="#研究主题" class="headerlink" title="研究主题"></a>研究主题</h2><h3 id="Key-theme-基于scRNA-seq预测细胞分化轨迹的软件。"><a href="#Key-theme-基于scRNA-seq预测细胞分化轨迹的软件。" class="headerlink" title="Key theme: 基于scRNA-seq预测细胞分化轨迹的软件。"></a><strong>Key theme</strong>: 基于scRNA-seq预测细胞分化轨迹的软件。</h3><h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary:"></a><strong>Summary</strong>:</h3><ul><li>无监督（无需先验知识）</li><li>基于“在分化过程中，转录多样性，即细胞中表达的基因数量，在分化过程中会减少”的理论</li><li>可识别与分化相关的基因</li></ul><h3 id="Research-Bacoground-x2F-Problem-statement"><a href="#Research-Bacoground-x2F-Problem-statement" class="headerlink" title="Research Bacoground&#x2F;Problem statement:"></a><strong>Research Bacoground&#x2F;Problem statement</strong>:</h3><p>  尽管已有大量用于预测谱系轨迹的计算方法，但它们通常依赖于（i）推断生物过程的起点（以及方向）的先验知识(比如monocle)和（ii）通过细胞中间状态来重建轨迹(比如Velocity)。</p><p>  此外，利用现有的计算机方法，很难将具有长期再生潜力的静态干细胞与更特化的细胞区分开来。尽管基于基因表达的模型有可能克服这些限制[例如转录熵（文献11-13）、多能性相关基因集（文献14）和机器学习策略（文献15）]，但它们在不同的发育系统和不同的测序平台中的实用性仍不清楚。</p><p>  基于RNA-based features，包括18,711个带注释的基因集(包含MSigDB,ENCODE和ChEA转录因子，mRNAsi肿瘤细胞Biomarker和三个计算机手段预测干性的StemID,SCENT,Slice)，作者确定了不受组织类型、物种和测序平台准确预测细胞分化状态的因素。<strong>基于“在分化过程中，转录多样性，即细胞中表达的基因数量，在分化过程中会减少”的理论</strong>，作者开发了<strong>无监督</strong>方法，用于预测单细胞转录组的相对分化状态。<strong>整体来说，使用CytoTRACE可以无需先验知识的定义分化起始点，并对一些干细胞相关基因进行排序，识别与干性和分化相关的基因。</strong></p><h3 id="Methods"><a href="#Methods" class="headerlink" title="Methods:"></a><strong>Methods</strong>:</h3><ol><li>在单细胞数据中筛选细胞分化的关键基因:</li></ol><ul><li>训练集：使用由 9 个具有实验确认的分化轨迹作为金标准的 scRNA-seq 数据集作为训练集。选择这些数据集是为了优先考虑早期研究中常用的基准数据集，并确保从哺乳动物受精卵到终末分化细胞的发育状态的广泛采样。训练集包含涵盖 2个物种（人和小鼠），49 个表型的 3174 个单细胞、六个组织和三个 scRNA-seq 平台(CEL-seq,Fluidigm C1, Tang在2009年首次报道的scRNA-seq技术)。</li><li>性能评估：使用 Spearman 相关性将每个基于 RNA 的基因（按表型平均）与已知的分化状态进行比较（图 1A）。然后，对九个训练数据集的结果进行平均，得出每个基因的最终分数和排名。图2B表明该方法揭示了许多已知的，和意想不到的分化状态相关性。<br>   <img src="/2023/12/22/CytoTRACE/F1.jpeg" alt="图1"></li><li><strong>结果</strong>：发现一个特征显示出显著的性能(104 of 18,711)：<strong>每个细胞可检测到的表达基因的数量（gene count）</strong>（可于上图中2B的蓝点中看到）。由于与成熟的干细胞特征相比，包括细胞周期和多能性基因 (14,15)，而且还显示出独特生物学的证据和更广泛的适用性（在cycling cells, noncycling cells, or published data from the earliest stages of human embryogenesis prior to the up-regulation of pluripotency factors中，基因计数都随着分化而减少）。基因计数可能超越孤立的实验系统，在不同细胞类型中概括发育潜力的全部范围。作者在秀丽隐杆线虫（图1D）和斑马鱼（表S4）中做了验证，表明<strong>gene count是细胞个体发育的一般特征</strong>。</li><li><strong>补充验证</strong>：由于细胞的转录输出与其全基因组染色质谱相关，接下来测试了单细胞基因计数是否最终可以替代全局染色质可及性（全局染色质可及性已被证明会随着分化而减少）。将来自 scRNA-seq 数据的单细胞基因计数与从最近一项人类胚胎干细胞 (hESCs) 体外中胚层分化研究中获得的配对bulk <strong>ATAC-seq</strong>（图1E）进行比较，发现随着 hESC 分化为近轴中胚层和侧中胚层谱系，观察到全基因组染色质可及性逐渐降低。</li></ul><ol start="2"><li><strong>CytoTRACE 的开发</strong>：<br>   <img src="/2023/12/22/CytoTRACE/F2.jpeg" alt="图2"></li></ol><ul><li>已知：每个细胞的表达基因数量通常与RNA丰度呈现正相关，但在部分数据集中，例如 hESC 体外分化为原肠胚层的数据集，<strong>每个细胞表达的基因数量表现出相当大的表型内变异</strong>（见图2A左）。</li><li>假设：由于 scRNA-seq 旨在捕获单细胞基因表达，而不是gene count，因此<strong>我们推断表达模式与基因计数相关的基因可能会更好地捕获分化状态</strong>。</li><li>验证：在预定义基因集和计算工具的测评中，通过计算每个数据集中基因计数最相关的基因的在每个细胞中表达水平的几何平均数，所得的<strong>基因计数特征（gene counts signature，GCS）</strong>成为在训练集中表现最好的方法。</li><li>优化运行速度：<strong>为了使性能最大化，与基因计数最正相关的top200基因在每个细胞中的集合表达量的平均值被定义为基因技术特征向量（GCS）。</strong></li><li><a href="https://www.jianshu.com/p/bff720322815">优化噪音</a>：虽然GCS改善了与单细胞分化状态的关联，但它还是<strong>存在明显的噪音表型内噪音</strong>（见图2A中间）。<strong>基于假设“转录相似的细胞有相似的分化状态”，作者实施了一个两步程序，根据单细胞之间的转录协方差直接平滑GCS。</strong>由此产生的方法，被称之为 <strong>CytoTRACE</strong> [<strong>全称：用于使用基因计数和表达进行细胞 (Cyto) 轨迹重建分析</strong>； <a href="https://cytotrace.stanford.edu]，优于">https://cytotrace.stanford.edu]，优于</a> GCS 和其评估的其他基于 RNA 的特征：<ul><li>预处理：输入原始counts矩阵，进行基因表达数量的检测，过滤NA值和低表达的基因（少于在5%细胞中表达的基因），利用行总和大于0进行筛选。按照批次对单细胞矩阵进行log2标准化，计算细胞间相关性矩阵(similarity matrix)，并基于相关性矩阵计算马尔可夫矩阵。</li><li>步骤一：计算top 200 GCS, 基于non-negative leaast squares regression(NNLS)获取期望的GCS（基于NNLS建立马尔可夫矩阵与GCS的回归关系）</li><li>步骤二：基于马尔科夫随机过程对期望的GCS进行迭代，优化矫正期望的GCS向量（即每个细胞中基因表达的几何平均数），指导期望的GCS达到平稳，然后最终按照GCS的大小进行排序，对此数值进行标准化（使其范围为0到1）来获得cytotrace的值。计算每一行基因（每个基因在不同细胞中的表达量向量）与cytotrace的皮尔森相关性。</li></ul></li></ul><ol start="3"><li>跨组织、物种和平台的性能评估</li></ol><ul><li>测试集：来自 26 项研究的 33 个额外 scRNA-seq 数据集。这些数据集代表了不同的发育和分化过程，由涵盖 266 个表型的 141,267 个单细胞、九个生物系统、五个物种 和 9 个 scRNA-seq 平台（三个droplet-based 和六个plate-based protocols）。</li><li>结果：在单细胞水平上进行评估时，CytoTRACE 的表现优于验证队列中所有评估的基于 RNA 的特征（图 2B）。在组织类型、物种、分析的细胞数量、时间序列实验与发育状态、或基于板的技术与基于液滴的技术方面，没有观察到显着的性能偏差。</li><li>与 RNA velocity的比较：两者数据集上表现相似，但 CytoTRACE 总体准确率更高（中位数分别为 74% 和 54%；图 S13C）。推测其可能是由于 RNA velocity模型假设的 mRNA 半衰期和发育时间尺度较短。 </li><li>CytoTRACE 是否可以应用于做过去批次的scRNA-seq 数据集：作者利用<a href="https://www.nature.com/articles/s41587-019-0113-3">Scanorama</a>中的最近邻和高斯核归一化技术合并了几个数据集。整合不同 scRNA-seq 平台上的数据集（图 3A）还是包含发育上不同的细胞类型的数据集（图 S14），Cytotrace的结果都是准确的。<br>  <img src="/2023/12/22/CytoTRACE/F3.jpeg" alt="图3"></li></ul><ol start="4"><li>寻找干细胞相关基因和谱系关系</li></ol><ul><li>无需先验知识的情况下识别不成熟表型marker的潜力的验证：见补充文本</li><li>与Monocle2的比较：当应用于 4442 个骨髓细胞时，Monocle 2 识别出 23 个可能的“root”，从中计算伪时间值（图 3B，左）。相比之下，CytoTRACE 无需用户输入即可轻松识别正确的root（图 3B，右侧，以及图 S16，A 和 B）。这些方法的整合促进了<strong>粒细胞、单核细胞和 B 细胞分化过程中谱系特异性调节因子和marker gene</strong>的自动识别（图 S16C）。<strong>小鼠肠细胞</strong>也获得了类似的结果（图 S16，D 至 F）</li><li>CytoTRACE 可以区分循环干细胞和长期或静态干细胞与其下游祖细胞：尽管循环和静止造血干细胞 (HSC) 亚群被正确预测为分化程度较低(low diff)，但只有增殖性HSC 的排名显着高于早期祖细胞（图 3C）。通过可视化推断的RNA含量与CytoTRACE的函数(图3D，顶部)，我们观察到RNA丰度的存在明显的低谷， 且其CytoTRACE的值与Hoxb5的表达升高相吻合，Hoxb5是长期或静止hsc的标记物(图3D，底部)。由于这些细胞不能单独通过基因计数或RNA含量来鉴定，因此该分析证实了CytoTRACE的实用性，并展示了一种从scRNA-seq数据中阐明组织特异性干细胞的方法。</li></ul><ol start="5"><li>在肿瘤疾病中的应用</li></ol><ul><li>CytoTRACE可用于研究在乳腺癌中未成熟的**管腔祖细胞(luminal progenitor,LP)**及其相关基因：使用 Smart-seq2 方案与荧光激活细胞分选 (FACS) 相结合，我们对来自三个主要人类上皮亚群的细胞进行索引分选和测序。<br>  <img src="/2023/12/22/CytoTRACE/F4.jpeg"></li><li>验证 CytoTRACE 定义 LP 分化状态的能力：低分化正常 LP [ALDH1A3 和 MFGE8 (39)] 和高分化正常 LP [GATA3、FOXA1 和 AR (39, 40)] 的标记基因通过这种方法成功富集（图 4B） ）。此外，在高克隆性正常 LP 中上调的基因 (39) 偏向于预测标记分化程度较低的细胞的基因（图 4B）</li><li>鉴定与肿瘤发生相关的 LP 基因: 使用Pearson correlation with CytoTRACE对在恶性LPs中表达的基因进行排序，在排序结果中观察到在患者来源的三阴性乳腺癌（TNBC）异种移植(PDX)模型中，通过RNA干扰(RNAi)敲低导致肿瘤细胞活力降低的基因显著富集（图4C）。此外，当我们应用CytoTRACE将肿瘤LPs中的基因与肿瘤**成熟管腔细胞(mature luminal，MLs，它处于LPs的发育下游)**进行优先排序时(39)，排名前15位的基因包括乳腺癌中已知的致瘤途径成员[例如MET和JAK1(42,43)]，以及未知的候选基因(例如GULP1)(图4D，顶部)。图4E和F用实验证明GULP1 敲低要么抑制肿瘤生长，要么完全消除肿瘤生长。</li></ul><h3 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion:"></a><strong>Conclusion</strong>:</h3><ul><li>证明了不太成熟的细胞保持较松散的染色质，以允许更广泛的转录组采样，而分化程度较高的细胞通常会限制染色质的可及性和转录多样性，因为它们specialize。</li><li>证明每个细胞表达基因的数量是发育潜力的标志。通过利用 scRNA-seq 数据的这一特性，开发了一个解决单细胞分化谱系关系的通用框架。我们设想我们的方法将<strong>补充现有的 scRNA-seq 分析策略</strong>，对整个多细胞生命中复杂组织中未成熟细胞及其发育轨迹的识别具有影响。</li></ul><h3 id="Notes-Optional"><a href="#Notes-Optional" class="headerlink" title="Notes(Optional):"></a><strong>Notes(Optional)</strong>:</h3><h3 id="Reference-Optional"><a href="#Reference-Optional" class="headerlink" title="Reference(Optional)"></a><strong>Reference(Optional)</strong></h3>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信</category>
      
      <category>文献笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VDJtools</title>
    <link href="/2023/08/31/VDJtools/"/>
    <url>/2023/08/31/VDJtools/</url>
    
    <content type="html"><![CDATA[<p>10X免疫组知识补充（VDJtools）</p><span id="more"></span><h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><p><img src="/2023/08/31/VDJtools/framework.png"><br>vdjtools 是一款基于 java 语言的， 借助 R 语言及相应的模块快速进行免疫组库分析软件(绘图都是基于R包)。<br><a href="https://vdjtools-doc.readthedocs.io/en/master/index.html">vdjtools 官网链接</a></p><h2 id="输入文件-Clonotype-tables"><a href="#输入文件-Clonotype-tables" class="headerlink" title="输入文件 Clonotype tables"></a>输入文件 Clonotype tables</h2><ul><li>可变 ( V ) 段名称。</li><li>D 段名称：一些受体链（TRB、TRD 和 IGH）的多样性 ( D ) 片段名称。如果不适用或未识别 D<br>段，设置为 . 或者 NA。</li><li>加入 ( J ) 段名称。</li><li>互补决定区 3 核苷酸序列 ( CDR3nt )。CDR3 以可变区参考点（保守的 Cys 残基）开始，以连接片<br>段参考点（保守的 PheTrp）结束。</li><li>翻译后的 CDR3 序列 ( CDR3aa )。</li><li>可变区段中的体细胞超突变 (SHM )（仅限抗体）</li></ul><p>克隆型丰度数据由 计数 和 频率 字段表示：</p><ul><li>计数：umis 数量</li><li>频率：样本中克隆型的比例（umis 数量&#x2F;总 umis 数量）</li></ul><p>以下字段是可选的，但用于计算各种统计数据和可视化：</p><ul><li>Vend、Dstart、Dend 和 Jstart：标记CDR3核苷酸序列的V、D、J段边界</li></ul><p><strong>输入文件格式</strong><br><img src="/2023/08/31/VDJtools/%E8%BE%93%E5%85%A5%E6%96%87%E7%8C%AE%E6%A0%BC%E5%BC%8F.png"></p><p><strong>metadata表格(以tab键分割)</strong><br><img src="/2023/08/31/VDJtools/metadata.png"></p><ul><li>file_name 和 sample_id两列是必须的。 其余列的名称将用于指定metadata 变量名。</li><li>前两列应分别包含文件名和样本 ID。（文件名应为绝对路径或相对于metadata表格的相对路径；样本ID必须是唯一的）</li><li>sample.id之后的列被视为 metadata 条目。后续作图时可以被调用。</li></ul><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a><a href="https://vdjtools-doc.readthedocs.io/en/master/modules.html">功能模块</a></h2>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>免疫组(RepSeq)</title>
    <link href="/2023/08/31/Immune/"/>
    <url>/2023/08/31/Immune/</url>
    
    <content type="html"><![CDATA[<p>10X免疫组知识补充</p><span id="more"></span><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="免疫组库测序"><a href="#免疫组库测序" class="headerlink" title="免疫组库测序"></a>免疫组库测序</h3><p>RepSeq: Immune repertoire sequencing</p><p><strong>免疫组库</strong>（Immune Repertoire，IR）是指某个个体在任何特定时间点其循环系统中所有功能多样性B淋巴细胞和T淋巴细胞的总和。</p><p>T细胞和B细胞分别介导机体的细胞免疫和体液免疫应答，分别通过其表面的T细胞受体（TCR）和B细胞受体（BCR）来识别和结合抗原，进而发挥功能清除病原体或体内肿瘤细胞。TCR&#x2F;BCR 上存在一块区域叫互补决定区（Complementary Determining Region, CDR），包含CDR1、CDR2、CDR3，其中CDR3最高变，在抗原识别中起关键作用。CDR3由V、D、J三个基因编码。</p><p><strong>BCR</strong><br>BCR 是在 B 细胞膜上表达的免疫球蛋白 (Ig) 的膜结合形式，由两条相同的重链 (IgH：µ，α，γ，δ，ε)和两条相同的轻链 (IgL：κ，λ) 通过二硫键连接而成。BCR 重链分为可变区（V 区）、恒定区（C 区）、跨膜区及胞质区；轻链则只有 V 区和 C 区。V 区由 3 个互补决定区（CDR1、CDR2 和 CDR3）组成，CDR 的氨基酸&#x2F;基因组成和排列顺序呈现高度多样性，在同一个体内，这种多样性可达 10<sup>9</sup>~10<sup>12</sup>，构成容量巨大的 BCR 库。正是这种多样性的存在，正常机体几乎能够对入侵的所有异物产生免疫应答。</p><p><strong>TCR</strong><br>TCR 是一种异二聚体，由 T 细胞膜表面两个二硫键连接的跨膜蛋白组成：一个 α 链和一个 β 链，或者一个 γ 链和一个 δ 链。α 和 β 链的 V 区包含 3 个互补决定区 CDRs 和 4 个框架区 FRs，其中 CDR 区是细胞的高变区，与抗原特异性结合，CDR1、CDR2 由 V 基因编码，而 CDR3 由 VDJ 三个基因编码，在免疫细胞成熟过程中 VDJ 基因发生重排从而形成了 TCR 多变性。而且多样性可达 10<sup>15</sup>~10<sup>18</sup>。<br><img src="/2023/08/31/Immune/%E7%BB%93%E6%9E%84.png"></p><h3 id="V-D-J-重排"><a href="#V-D-J-重排" class="headerlink" title="V(D)J 重排"></a>V(D)J 重排</h3><p>如下图所示，编码重链基因的的染色体包括4种DNA元件(基因片段)，分别是 V,D,J,C。 </p><ul><li><strong>BCR</strong><br>在人类<strong>B细胞</strong>中，V 片段大约有50种， D 片段大约有20种， J 片段大约有6种， C 片段大约有10种。而每个特异 B 细胞就是通过选择每类片段中的一种，并将它们组合在一起，以组装成一个成熟的<strong>重链</strong>基因。同理， <strong>轻链</strong>包括3种DNA元件，分别是 V,J,C。通过这样的方式， B细胞就可以产生种类巨多的抗体分子。但这样还不够，当基因片段组合在一起后，还会有额外的DNA碱基插入或者去除，以增加组合多样性。<br><img src="/2023/08/31/Immune/%E9%87%8D%E6%8E%92.png"></li></ul><p>一个B细胞克隆只表达一种BCR，只分泌一种抗体，原因：</p><ol><li>等位排斥：B细胞一条染色体的重链基因重排成功后，会抑制同源染色体上重链基因的重排；</li><li>同种排斥：kappa轻链基因重排成功后会抑制lambda轻链基因的重排；</li><li>B细胞中枢免疫耐受的形成——阴性选择</li></ol><p>前B细胞在骨髓中发育至未成熟B细胞后，期表面只表达完整的mIgM，此时若mIgM与自身抗原结合，会面临三种命运：</p><ol><li>细胞凋亡，克隆清除；</li><li>通过受体编辑改变其BCR的特异性；</li><li>mIgM表达下调，仍然能进入外周免疫器官，但对抗原刺激不发生应答，称为“失能”；</li></ol><ul><li><a href="https://github.com/Ming-Lian/NGS-analysis/blob/master/RepSeq.md#ref9"><strong>TCR</strong></a></li></ul><p>TCR异二聚体的α和β链由可变区（V）和恒定区（C）组成，它们在胸腺发育过程中被拼接在一起，从而产生由每种T表达的单一类型的功能性TCRαβ复合物细胞</p><p>β链的V区由可变（V），多样性（D）和连接（J）基因片段编码，而α链的V区由V和J基因片段编码</p><p>TRB的候选基因片段数量：<br>    TRBV：52<br>    TRBD：2<br>    TRBJ：13</p><p>TRA的候选基因片段数量：<br>    TRAV：70<br>    TRAJ：61</p><h2 id="AIRR社区"><a href="#AIRR社区" class="headerlink" title="AIRR社区"></a><a href="https://www.antibodysociety.org/the-airr-community/">AIRR社区</a></h2><p><strong>The Adaptive Immune Receptor Repertoire (AIRR)</strong></p><ul><li>获取、分析、管理和比较&#x2F;共享 AIRR-seq 数据集;</li><li>开发标准化资源，以促进AIRR-seq数据集和分析工具的比较</li><li>审查 AIRR-seq 数据分析工具是否符合 AIRR;</li><li>将AIRR-seq数据集与其他“大数据”集相关联，例如微阵列，流式细胞术和MiSeq以及单细胞基因表达数据;</li><li>涉及使用和共享来自人类来源的AIRR-seq数据集的法律和道德问题。</li><li>建立将存储AIRR数据的存储库的要求</li></ul><h2 id="10x-vdj测序"><a href="#10x-vdj测序" class="headerlink" title="10x vdj测序"></a><a href="https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/using/vdj">10x</a> vdj测序</h2><p>10x Genomics 5’ Chromium Next GEM 单细胞免疫分析解决方案能够以单细胞分辨率同时分析同一组细胞的这些文库：</p><ul><li>T细胞的V（D）J转录组和克隆型</li><li>B细胞的V（D）J转录组和克隆型</li><li>5’ 单细胞基因表达</li><li>细胞表面蛋白（抗体捕获）</li><li>基于条形码的抗原特异性克隆型图谱(Barcode Enabled Antigen Mapping，BEAM) （抗原捕获）</li></ul><h3 id="cellranger-vdj"><a href="#cellranger-vdj" class="headerlink" title="cellranger vdj"></a>cellranger vdj</h3><p>cellranger vdj 从 cellranger mkfastq V（D）J 库中或 bcl2fastq 为 V（D）J 库获取 FASTQ 文件，并执行序列组装和成对克隆型调用。它使用Chromium cellular barcodes 和UMI来组装每个细胞的V（D）J转录本。克隆型和CDR3序列作为 .vloupe 文件输出，可以加载到Loupe V（D）J browser中。</p><h4 id="分析结果解读："><a href="#分析结果解读：" class="headerlink" title="分析结果解读："></a><strong>分析结果解读：</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stylus">── runs<br>    └── HumanB_Cell<br>          └──outs<br>              ├── airr_rearrangement<span class="hljs-selector-class">.tsv</span><br>              ├── all_contig_annotations<span class="hljs-selector-class">.bed</span><br>              ├── all_contig_annotations<span class="hljs-selector-class">.csv</span>  <br>              ├── all_contig_annotations<span class="hljs-selector-class">.json</span><br>              ├── all_contig<span class="hljs-selector-class">.bam</span><br>              ├── all_contig<span class="hljs-selector-class">.bam</span><span class="hljs-selector-class">.bai</span><br>              ├── all_contig<span class="hljs-selector-class">.fasta</span><br>              ├── all_contig<span class="hljs-selector-class">.fasta</span><span class="hljs-selector-class">.fai</span><br>              ├── all_contig<span class="hljs-selector-class">.fastq</span><br>              ├── cell_barcodes<span class="hljs-selector-class">.json</span><br>              ├── clonotypes<span class="hljs-selector-class">.csv</span><br>              ├── concat_ref<span class="hljs-selector-class">.bam</span><br>              ├── concat_ref<span class="hljs-selector-class">.bam</span><span class="hljs-selector-class">.bai</span><br>              ├── concat_ref<span class="hljs-selector-class">.fasta</span><br>              ├── concat_ref<span class="hljs-selector-class">.fasta</span><span class="hljs-selector-class">.fai</span><br>              ├── consensus_annotations<span class="hljs-selector-class">.csv</span><br>              ├── consensus<span class="hljs-selector-class">.bam</span><br>              ├── consensus<span class="hljs-selector-class">.bam</span><span class="hljs-selector-class">.bai</span><br>              ├── consensus<span class="hljs-selector-class">.fasta</span><br>              ├── consensus<span class="hljs-selector-class">.fasta</span><span class="hljs-selector-class">.fai</span><br>              ├── filtered_contig_annotations<span class="hljs-selector-class">.csv</span><br>              ├── filtered_contig<span class="hljs-selector-class">.fasta</span><br>              ├── filtered_contig<span class="hljs-selector-class">.fastq</span><br>              ├── metrics_summary<span class="hljs-selector-class">.csv</span><br>              ├── vdj_contig_info<span class="hljs-selector-class">.pb</span><br>              ├── vdj_reference<br>              │   ├── fasta<br>              │   │   ├── donor_regions<span class="hljs-selector-class">.fa</span><br>              │   │   └── regions<span class="hljs-selector-class">.fa</span><br>              │   └── reference<span class="hljs-selector-class">.json</span><br>              ├── vloupe<span class="hljs-selector-class">.vloupe</span><br>              └── web_summary.html<br></code></pre></td></tr></table></figure><p><a href="https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/output/overview">10X官方解释链接</a></p><ul><li><p>vdj_contig_info.pb: 以 protobuf 二进制文件格式<strong>存储contig注释</strong>、V（D）J 引用和其他metadata。<strong>运行 cellranger aggr 管道所需的文件。此文件仅用于用作 Cell Ranger aggr 管道的输入，不得用作数据源。</strong>vdj_contig_info.pb 中包含的信息也可以在其他易于解析的输出文件中找到，例如 all_contig_annotations.json 、 vdj_reference 和 metrics_summary.csv 。</p></li><li><p>clonotypes.csv: 每个克隆型(clonotype)的高级描述。包含clonotype_id(按照frequency排序，ID从低到高)；Frequency（观察到的具有此克隆型的细胞barcodes的数量）；Proportion（观察到的具有此克隆型的细胞barcodes的比例）； cdr3s_aa(CDR3氨基酸序列，链包含TRA，TRB，TRG，TRD，IGK，IGL或IGH)；cdr3s_nt(CDR3核苷酸序列)；inkt_evidence（对于T细胞，这列指示clonotype是否是一组 invariant natural killer T ，即inkt细胞）；mait_evidence（对于T细胞，这列指示是否为mucosal-associated invariant T，即MAIT细胞）</p></li></ul><p>注：关于INKT及MAIT细胞的信息见<a href="https://www.annualreviews.org/doi/abs/10.1146/annurev-immunol-032414-112008">链接</a></p><ul><li>consensus_annotations.csv：每个克隆型共有序列(consensus sequence)的高级和详细注释。</li></ul><p>注：10X的Csv表格输出都是用于高级注释，每行有一个contig, consensus, 或者 clonotype.</p><ul><li><p>all_contig_annotations.csv：CSV 格式的所有重叠群（contigs）（来自细胞和背景条形码）的高级和详细注释。</p></li><li><p>filtered_contig_annotations.csv：来自细胞相关barcodes的每个高置信度重叠群的高级注释。这是一个all_contig_annotations.csv 子集.</p></li><li><p>all_contig_annotations.bed：BED 格式的所有重叠群（来自细胞和背景条形码）的高级和详细注释。Browser Extensible Data，字面意思是“（基因组）浏览器可延展数据”，是一种基因组学中用于表示、标记基因组区域位置信息中的文件格式，与IGV等可视化工具一同使用。</p></li><li><p>all_contig_annotations.json：JSON 格式的所有重叠群（来自细胞和背景条形码）的高级和详细注释。Json格式含有详细的注释，包括contig的完整序列，contig的具体坐标和氨基酸翻译序列。</p></li><li><p>airr_rearrangement.tsv ： <a href="https://docs.airr-community.org/en/stable/">AIRR格式</a>的带注释的重叠群和 V(D)J 重排的共有序列。</p></li><li><p>vloupe.vloupe: Loupe V(D)J Browser readable file</p></li></ul><p>典型V（D）J转录的结构<br><img src="/2023/08/31/Immune/vdj_transcript_features.png"><br>UTR：未翻译的区域;<br>FWR：框架区域（Framework region）;<br>CDR：互补性决定区域</p><p>名词解释：</p><ul><li><p>contig：带有<strong>相同的 cell barcode</strong> 和 UMI 且比对到相同转录本序列的 reads 被组装为 contigs。（由组装产生的连续的碱基序列）</p></li><li><p>full-length: 如果重叠群与 V 基因的起始部分相匹配，继续下去，并最终与 J 基因的末端部分相匹配，则该contig是全长的。(可以没有d_gene)</p></li><li><p>Clonotype(克隆型): 一组适应性免疫细胞，是完全重组、未突变的共同祖先的克隆后代。T细胞克隆型通常由重排的TCR的核苷酸序列来区分，在大多数脊椎动物物种中，TCR不经历体细胞超突变(SHM)。如上所述，B细胞克隆型通常在核苷酸水平上彼此不同。由于这个原因，B细胞克隆型也经常包含多个精确的亚克隆型.</p></li></ul><p>10X的判断方式：<br>优先考虑TRA和TRB所有cdr3_nt都匹配，分配到同一个clonotype。(所有的Exact subclonotype都匹配)</p><p>若A细胞中只含有单一的TRA序列（该细胞不含TRB），该序列完全匹配到B细胞的TRA（B细胞可以含有TRA或TRB），则会为A细胞的TRA序列分配一个clonotype ID，且把B细胞全部分配到该Clonotype ID上.（A细胞中只有一个Exact subclonotype，且该Exact subclonotype与B细胞的Exact subclonotype匹配，即使B细胞存在其余Exact subclonotype，A和B细胞也会被分到同样的Clonotype ID）</p><ul><li><p>Exact subclonotype（精确亚克隆型）: 在核苷酸水平上具有相同免疫受体序列的克隆型细胞的一个亚群，横跨整个V、D和J基因以及V(D)J连接。精确的亚克隆型共享相同的V、D、J和C基因注释(例如，具有相同的V(D)J序列但不同的C基因或同型的细胞被分成不同的精确亚克隆型)。</p></li><li><p>Consensus（一致性序列）：给定clonotype ID的一致序列是该链在第一个精确亚克隆型的核苷酸序列。</p></li><li><p>productive（生产性）:<br>如果满足以下条件，则重叠群被称为生产性的（有prodictive 的TCR&#x2F;BCR才能翻译有功能的蛋白）：</p></li></ul><ol><li>full length: contig 与 V 基因的初始部分相匹配。contig 继续，最终匹配 J 基因的末端部分。</li><li>可编码正常氨基酸：V片段的起始部分与config的起始密码子相匹配（在 10x Genomics 提供的人类和小鼠参考序列中，每个 V 区段都以起始密码子开头。），也就是有起始密码子；V 片段起始和 J结尾之间没有终止密码子；J 停止减去 V 开始等于一模三。这只是说 V 和 J 片段上的密码子在框内（编码范围内没有移码突变）。</li><li>CDR3：有一个带注释的 CDR3 序列。</li><li>结构：令 VJ 表示 V 和 J 段的长度之和。让 len 表示 J 停止减去 V 开始，在重叠群上测量。那么 VJ -len 介于 -25 和 +25 之间，除了 IGH，它必须介于 -55 和 +25 之间。施加此条件是为了排除不太可能与功能蛋白相对应的异常结构变化。</li></ol><ul><li>high_confidence contig(高质量contig): 有两个以上的UMI支持的productive contig为高质量的contig.</li></ul><h3 id="cellranger-multi"><a href="#cellranger-multi" class="headerlink" title="cellranger multi"></a>cellranger multi</h3><p>cellranger multi 从单个 GEM 孔中获取 5’ 基因表达、基因barcodes（抗体捕获、CRISPR Guide Capture和&#x2F;或抗原捕获）和 V（D）J 文库的任意组合的 FASTQ 文件 cellranger mkfastq bcl2fastq 。它对基因表达和&#x2F;或Feature Barcode (FB)执行比对、过滤、barcodes计数和 UMI 计数。它还对 V（D）J 文库执行序列组装和成对克隆型调用。此外，基因表达数据提供的cell call用于改进V（D）J文库推断的cell call。</p><h4 id="分析结果解读：-1"><a href="#分析结果解读：-1" class="headerlink" title="分析结果解读："></a><strong>分析结果解读：</strong></h4><p><img src="/2023/08/31/Immune/multi_outputs.png"><br><a href="https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/output/overview-multi">10X官方解释链接</a></p><p>该 cellranger multi pipeline通过丢弃在相应的 5’ 基因表达数据集中未调用的任何细胞来改进 V（D）J 数据集中的细胞调用。通过将 V（D）J 结果中调用但未在 5’ 基因表达结果中调用的细胞指定为 V（D）J 数据中的背景 GEM， cellranger multi 可以减轻 V（D）J 数据中可能出现的任何超调问题。这种改进的细胞调用只有在从同一样品中同时测序5’基因表达和V（D）J文库时才有可能。</p><p>如下图所示，最终的 V（D）J 单元调用（交集区域）排除仅由 vdj 管道调用的单元（黄色区域）。（<strong>最终获得的细胞barcodes在VDJ数据和转录组数据中是一致的</strong>）</p><p><img src="/2023/08/31/Immune/why-use-multi.png"></p><p>5’ 基因表达细胞调用不受 cellranger multi 管道影响。基因表达文库代表了每个GEM中捕获的整个聚腺苷酸化mRNA转录本库。然后选择性扩增基因表达文库中的VDJ-T或VDJ-B转录本以创建V（D）J文库。因此，与 V（D）J 文库相比，基因表达文库具有更强的检测含有细胞的 GEM 的能力。如果 cellranger multi 管道同时使用 5’ 基因表达和 V（D）J 数据运行，则从 V（D）J 细胞集中删除在 5’ 基因表达数据中未称为细胞的条形码。</p><p>从Cell Ranger 7.0开始，multi可以自动估计或指定 expect-cells 预期的细胞数量（例如，复制先前的分析）(force cell)</p><p>该 cellranger multi 管道允许用户分析富集为 gamma (TRG) 和 delta (TRD) 链的 TCR 库。但是，Gamma-delta 分析不是受支持的工作流程，并且无法保证算法性能。TRG&#x2F;D 输出位于 和 outs&#x2F;per_sample_outs&#x2F;mySample&#x2F;vdj_t_gd 文件夹中 outs&#x2F;multi&#x2F;vdj_t_gd 。文件夹中的 vdj_t_gd 输出文件与 的 vdj_t&#x2F;b 输出文件类似。</p><h3 id="cellranger-aggr"><a href="#cellranger-aggr" class="headerlink" title="cellranger aggr"></a><a href="https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/using/aggr">cellranger aggr</a></h3><p>Cellranger AGGR 整合来自多次运行 cellranger count cellranger vdj 、 或 cellranger multi 的输出。该管道将 aggr 单个基因表达和Feature Barcode (FB)运行规范化到相同的测序深度，重新计算feature barcodes矩阵并对组合数据进行分析。该pipeline还会重新计算组合数据的 V（D）J 克隆型分组。<br><img src="/2023/08/31/Immune/vdg_aggr_input_csv.png"></p><h2 id="Cellranger-VDJ算法概述"><a href="#Cellranger-VDJ算法概述" class="headerlink" title="Cellranger VDJ算法概述"></a>Cellranger VDJ算法概述</h2><p>cellranger vdj 针对FASTQ 文件执行序列组装和配对克隆型调用。该管道使用10x barcodes和 UMI 来组装每个细胞的 V（D）J 转录本。克隆型和CDR3序列作为 .vloupe 文件输出，可以加载到Loupe V（D）J浏览器中。</p><p><img src="/2023/08/31/Immune/algorithm-workflow.png"></p><ol><li>contigs组装</li></ol><ul><li>过滤掉可能由PCR错误、测序错误等引起的带有背景barcodes和UMI的读取。</li><li>一些细胞具有极高的覆盖率。高覆盖率可能是由于真正的高测序覆盖率，或浆细胞中的高mRNA表达（常见于BCR）。转录本的超高覆盖率（大于 80，000 个reads）会降低计算性能并添加很少的额外信息。因此，每个barcodes的覆盖范围上限为最多 80，000 次reads。如果任何给定的 10x barcodes的读取次数超过 80，000 次，则对读取进行downsample。</li><li>从reads的 5’ 和 3’ 端修剪adaptor和引物序列。</li><li>从所有观察到的 GEM&#x2F;条形码中的每条链生成全长转录本（contigs）。</li></ul><ol start="2"><li>注释Contig<br>V（D）J重叠群注释的三个目标是：<br>1）定义V，D和J片段与contig的比对<br>2）识别CDR3序列<br>3）从这些数据中确定contig是否productive，这意味着它可能对应于功能性T细胞或B细胞受体。</li></ol><ul><li>用 V（D）J 片段标签注释contig，并定位形成转录本的 CDR3 区域。</li><li>过滤全长且productive的重叠群。</li><li>重叠群置信度：不正确的克隆型可能来自细胞外mRNA或双峰等来源。为了防止这种情况，将评估重叠群的置信度，并排除那些被宣布为低置信度的重叠群。所有非生产性重叠群均被声明为低置信度。对于参考辅助装配，如果满足以下任一条件，则生产重叠群的置信度较低：有四个以上的productive contigs；每个链有两个以上的重叠群（例如三个TRA重叠群）：预计每个细胞相关条形码都有一个productive TRA chain和一个productive TRB chain用于T细胞，一个productive重链和一个productive轻链用于B细胞。额外productive contigs不太合理；少于三个filtered UMI （每个 UMI 至少具有三个reads）；所有productive contig最多有一个连接 UMI 支持，并且每个过滤的 UMI 少于 5 个，每个 UMI 至少具有三个reads，或者有两个以上的生产性重叠群;</li></ul><p><a href="https://blog.csdn.net/u010608296/article/details/102771217?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163483133716780274188627%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163483133716780274188627&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-102771217.pc_search_result_hbase_insert&utm_term=N50&spm=1018.2226.3001.4187">N50 定义</a>  </p><ol start="3"><li><p>细胞识别<br>识别包含 T 或 B 细胞的barcodes&#x2F;GEMs。</p></li><li><p>生成clonotype(克隆型)<br>将细胞相关barcodes分配到克隆型中并过滤掉一些细胞。</p></li></ol><p>主要从all_contig_annotations.json的Cell Ranger文件中获取其信息。</p><p>在克隆性计算过程中，会对细胞进行过滤（过滤Technical artifacts）。</p><p>T细胞：T细胞受体（TCR）中缺乏体细胞超突变（SHM）会产生具有相同V（D）J 转录本的生物克隆型。技术伪影（Technical artifacts ）（例如在逆转录中出现）可能导致计算出的克隆型具有独立的差异。这些很少见。</p><p>B cells: Fully rearranged B cell receptors (BCRs) can undergo SHM, which can increase antigen affinity. Thus for BCRs, V(D)J transcripts in a clonotype can differ at any position, as shown below:<br>B细胞：完全重排的B细胞受体（BCR）可以经历SHM，这可以增加抗原亲和力。因此，对于BCR，克隆型中的V（D）J转录本在任何位置都可能不同，如下所示：<br><img src="/2023/08/31/Immune/what_is_a_clonotype.png"><br>Cellranger只考虑V 基因位置的种系变异评估（SHM）， 不考虑J基因的SHM。</p><p>步骤：<br>(1) Exact subclonotype grouping精确的亚克隆型分组</p><p>如果细胞具有相同的V（D）J转录本，则将其放入称为精确亚克隆型的组中。仅使用productive重叠群。精确亚克隆型必须具有相同数量的链。它们的V（D）J序列和恒定区域基因分配也必须相同。精确亚克隆型不需要具有相同的 5’ UTR。此外，该算法不会在 5’ UTR 或恒定区域中测试 SHM。</p><p>（2）将精确亚克隆型连接成克隆型</p><p>基于将每对精确亚克隆型相互比较而迭代合并为克隆型。具有共同差异和最小CDR3突变的两个细胞被认为是同一克隆型。此处简要介绍了合并条件。<br><a href="https://10xgenomics.github.io/enclone/pages/auto/help.how.html">10X enclone 算法摘要</a><br><a href="https://www.biorxiv.org/content/10.1101/2022.04.21.489084v2.full">10X enclone 算法文献</a><br><a href="https://10xgenomics.github.io/enclone/">10X enclone 命令行版本（Beta版本）</a><br><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9731466/">相关文献</a><br><a href="https://10xgenomics.github.io/enclone/pages/auto/default_filters.html">Cellranger中默认启动如下Enclone配置</a><br><a href="https://support.10xgenomics.com/single-cell-vdj/software/pipelines/latest/algorithms//glossary#origin">Cellranger术语表</a><br><a href="https://kb.10xgenomics.com/hc/en-us/articles/4863509310093-Web-summary-metrics-for-V-D-J-Troubleshooting">Web summary metrics for V(D)J Troubleshooting</a><br><a href="https://www.10xgenomics.com/resources/analysis-guides/immune-profiling-analysis-whats-next-after-cell-ranger">10X官方推荐下游分析软件</a></p>]]></content>
    
    
    <categories>
      
      <category>知识补充</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>知识补充</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>音乐剧杂谈</title>
    <link href="/2023/06/20/%E9%9F%B3%E4%B9%90%E5%89%A7202306/"/>
    <url>/2023/06/20/%E9%9F%B3%E4%B9%90%E5%89%A7202306/</url>
    
    <content type="html"><![CDATA[<p>在音乐剧中寻找现实与虚幻交界点，今天也是喜欢音乐剧的现在进行时。</p><span id="more"></span><h1 id="与音乐剧的初相遇"><a href="#与音乐剧的初相遇" class="headerlink" title="与音乐剧的初相遇"></a>与音乐剧的初相遇</h1><p>初次音乐剧结缘，是在2020年。我偶然在B站首页刷到了一个标题 “【音乐剧汉化】Next to Normal 《近乎正常》”的视频。简单的剧名，却带着击中人心的力量。带着强烈的好奇心，我打开了音乐剧的大门。与完全使用歌唱和音乐来表达剧情的歌剧不同，音乐剧是更加“平易近人”的舞台艺术形式，融合喜剧，对白，和歌舞，通过台词、音乐和肢体动作的紧密结合，展现故事情节并传达情感。</p><h1 id="Next-to-Normal"><a href="#Next-to-Normal" class="headerlink" title="Next to Normal"></a>Next to Normal</h1><p>《近乎正常》（Next to Normal）是一部来自美国百老汇的音乐剧，选材小众，故事围绕着躁郁症、死亡、药物滥用和疾病对她家人的影响展开。剧中的每个角色都处在挣扎和失控的边缘，努力想做到外人眼中的“正常”甚至完美的一家，却为此承担了巨大的心理压力。最终他们终于领悟到，没有必要定义所谓正确的生活方式，因为家家有本难念的经，情绪和心理问题是普遍存在的，及时调整并换种方式把握自己的生活也许会是最好的选择。剧中的“You Don’t know”唱段用摇滚风音乐，体现了作为躁郁症患者不被人接受，不被人理解的痛苦发泄。结尾的“Light”唱段非常治愈：</p><pre><code class="hljs">Give me pain if that&#39;s what&#39;s real 给我真实的痛苦It&#39;s the price we pay to fell 活着总是伴着付出The price of love is loss 爱也伴着失去But still we pay 但别在乎We love anyway 我们仍勇敢在爱着And when the night has finally gone 当长夜终于走到尽头And when we see the new day dawn 当黎明绽放在窗口We&#39;ll wonder how we wandered for so long, so blind 你会笑话自己茫然彷徨那么久</code></pre><p><img src="/2023/06/20/%E9%9F%B3%E4%B9%90%E5%89%A7202306/Next_to_Normal_original_poster_art.jpg"></p><h1 id="Hamilton"><a href="#Hamilton" class="headerlink" title="Hamilton"></a>Hamilton</h1><p>我入坑后看的第二部音乐剧是极具影响力，舞台体验酣畅淋漓，适合音乐剧爱好者入门的现象级音乐剧 ————《汉密尔顿》（Hamilton），该作以美国国父汉密尔顿传记为主题，采用说唱形式展现，带有明显的美国个人英雄主义特色。作为主角的汉密尔顿出身低微但大胆进取，拥有雄辩之才和出众的政治智慧，最终凭借头脑和勤奋出人头地。剧情节奏紧凑，逐渐从对汉密尔顿个人角度的叙述变成了一个国家的集体叙事，融合超凡脱俗的舞美，带来了极佳的观剧体验。从音乐角度来看，《汉密尔顿》将新唱法融合进入音乐剧，取得了开创性的成就。“My shot”唱段展现了汉密尔顿意气风发，才华横溢的青年形象，热血且励志。“Who lives, who dies, who tells your story”从汉密尔顿妻子，伊莱扎的角度讲述了她如何建立了纽约第一个私人孤儿院，抚养了一代又一代的孤儿，坚强的生活并最终将汉密尔顿的故事传唱。整部剧的音乐性极强，完全不会有令人失望的曲目。</p><p><img src="/2023/06/20/%E9%9F%B3%E4%B9%90%E5%89%A7202306/%E6%B1%89%E5%AF%86%E5%B0%94%E9%A1%BF.jpeg"></p><h1 id="Les-Miserables"><a href="#Les-Miserables" class="headerlink" title="Les Misérables"></a>Les Misérables</h1><p>第三部剧是名著改编的音乐剧《悲惨世界》(Les Misérables)，作为一部以罪犯和警察的猫鼠游戏为主线，描述法国底层人民的悲惨生活，并以法国革命动乱作为背景，展现街垒起义时年轻人们敢为天下先，不惜生命推动人类的进步和救赎的时代画像。《悲惨世界》描绘了一个黑暗的时代，却是从人性光辉的一面着手，带着震撼人心的艺术魅力。剧中经典唱段“Do You Hear the People Sing”，被翻译成不同的版本，带着振奋人心的力量，在不同的国家演出。唱段“One Day More”，从开始冉阿让的独唱到各个角色逐渐加入，音色交织，带来了绝无仅有的震撼和宿命感。</p><p><img src="/2023/06/20/%E9%9F%B3%E4%B9%90%E5%89%A7202306/%E6%82%B2%E6%83%A8%E4%B8%96%E7%95%8C.jpg"></p><h1 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h1><p>《歌剧魅影》、《致埃文汉森》、《罗密欧与朱丽叶》、《摇滚莫扎特》、《伊丽莎白》等音乐剧，涵盖了英国、美国、法国、德国和中国等不同国家和语言的多种题材，形式各异、主题丰富，宛如一座宝藏。在剧中的人物身上找到共鸣，体会现实生活中也许永远无法体会的情感和经历，寻宝一样挖掘各种小众题材音乐剧，对我来说，每场音乐剧都是一场独特的旅程。能够帮助我们短暂的放下现实生活中的一切，沉浸在音乐剧的世界里，借助音乐的力量，追寻和接纳自我，并以不完美的姿态勇敢地生活下去，也许就是音乐剧的魅力吧。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zotero配置</title>
    <link href="/2023/06/05/Zotero/"/>
    <url>/2023/06/05/Zotero/</url>
    
    <content type="html"><![CDATA[<p>本文保存Zotero常用插件</p><span id="more"></span><h2 id="ZotFile-附件管理（建议改用官方拼车）"><a href="#ZotFile-附件管理（建议改用官方拼车）" class="headerlink" title="ZotFile 附件管理（建议改用官方拼车）"></a>ZotFile 附件管理（建议改用官方拼车）</h2><p>结合360云盘进行pdf多端同步，用于管理文献附件，例如移动、重命名等。</p><p>移动附件到指定文件夹，文献条目上右键单击『Manage Attachments』→『Rename and Move』</p><h2 id="Zotero-gpt-辅助阅读"><a href="#Zotero-gpt-辅助阅读" class="headerlink" title="Zotero-gpt 辅助阅读"></a>Zotero-gpt 辅助阅读</h2><p><a href="https://github.com/MuiseDestiny/zotero-gpt">Zotero gpt下载链接</a></p><p>下载.xpi并安装，需要结合chatGPT的API key使用。</p><p>辅助进行内容提炼，总结，或部分翻译。</p><h2 id="zotero-pdf-translate-翻译神器"><a href="#zotero-pdf-translate-翻译神器" class="headerlink" title="zotero-pdf-translate 翻译神器"></a>zotero-pdf-translate 翻译神器</h2><p><a href="https://github.com/windingwind/zotero-pdf-translate">下载链接</a></p><p>建议使用CNKI翻译。</p><h2 id="zotero期刊显示影响因子"><a href="#zotero期刊显示影响因子" class="headerlink" title="zotero期刊显示影响因子"></a>zotero期刊显示影响因子</h2><p><a href="https://zhuanlan.zhihu.com/p/668106876">参考教程</a><br>安装zotero style插件，搭配easyscholar使用</p><h2 id="zotero搭配obsidian-使用"><a href="#zotero搭配obsidian-使用" class="headerlink" title="zotero搭配obsidian 使用"></a>zotero搭配obsidian 使用</h2><p>安装BibTex for zotero</p><h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h2><p>可使用<a href="https://werss.app/">WERSS</a>订阅公众号，并使用<a href="https://github.com/yang991178/fluent-reader">Fluent reader</a>获得纯净的阅读体验。</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文献</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WGCNA文献学习与配置</title>
    <link href="/2023/05/22/WGCNA/"/>
    <url>/2023/05/22/WGCNA/</url>
    
    <content type="html"><![CDATA[<p>WGCNA文献和hdWGCNA文献阅读</p><span id="more"></span><h1 id="WGCNA介绍"><a href="#WGCNA介绍" class="headerlink" title="WGCNA介绍"></a>WGCNA介绍</h1><p><a href="https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-9-559">WGCNA 文献</a></p><p><a href="https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/">WGCNA 教程页面</a></p><p><a href="https://peterlangfelder.com/articles/">作者 Peter Langfelder 博客</a></p><p><a href="https://www.jianshu.com/p/1804fb6d2ed8">一篇讲解清晰的blog</a></p><h2 id="研究背景"><a href="#研究背景" class="headerlink" title="研究背景"></a>研究背景</h2><p>Weighted correlation network analysis （WGCNA）是一种系统生物学方法，用于描述bulk RNA-seq中基因之间的相关性模式。WGCNA可用于寻找高度相关基因的聚类(module)，使用模块的特征基因或模块内hub基因对基因聚类情况进行汇总，将模块相互关联并与外部样本性状(使用特征基因网络方法)相关联，计算模块隶属度指标（模块与性状的关联）。该方法为基于网络的基因筛选方法提供了便利，可用于识别候选生物标志物或治疗靶点。这些方法已成功应用于多种生物背景，如癌症、小鼠遗传学、酵母遗传学、脑成像数据分析等。WGCNA R软件包是R函数的综合集合，包括网络构建、模块检测、基因选择、拓扑性质计算、数据模拟、可视化以及与外部软件接口等功能。</p><p>流程图<br><img src="/2023/05/22/WGCNA/P1.png"></p><ol><li>构建基因共表达矩阵网络：计算基因间相关性<ul><li>基于Spearman method计算基因的相关性矩阵(<strong>Similarity Matrix</strong>)</li><li>将相关性矩阵转化为邻接矩阵(<strong>Adjacency Matrix</strong>)；Similarity Matrix被认为是undirected, weighted gene network，因此从Similarity Matrix转换到Adjacency Matrix的过程，被认为是从无向加权网络<strong>转移到scale-free network的过程</strong>。<ul><li>此步骤需要选择网络的类型(<strong>官方更推荐Signed或者Signed hybrid</strong>)<ul><li>Unsigned: Genes are similar if they are strongly correlated</li><li>Signed: Only applied to genes that are similar if they are <strong>positively correlated</strong></li><li>Signed hybrid: Negative associations are all treated as zero. (与signed network类似，与Signed network的差异可以很小)</li></ul></li><li>根据两个标准，选择<strong>soft thresholding β值</strong> (Power selected)；soft thresholding β值用于将Similarity Matrix转换到Adjacency Matrix<ul><li>Scale independence, 该图的点的纵坐标越高，越接近scale free network。</li><li>Mean Connectivity；由于在scale free network中，大多数节点的连通性较差，因此平均连通性越低，越接近scale free network。<br> <img src="/2023/05/22/WGCNA/P3.png"></li></ul></li></ul></li><li>根据Adjacency Matrix绘制TOM plot (<strong>topological overlap matrix</strong>)<ul><li>基因网络的拓扑重叠热图(Heatmap plot of topological overlap in the gene network)是对基因相似性的评估。</li><li>在热图中，每一行和每一列对应一个基因，浅色表示低拓扑重叠，渐变深的红色表示高拓扑重叠。如果基因在网络中与相似的一组基因相连，那么它们被认为具有高度的拓扑重叠。</li></ul></li></ul></li><li>模块寻找：基于矩阵的数值进行成对比较，进行层次聚类，并通过Dynamic tree cut对聚类树进行模块划分<ul><li>模块的特征向量值signed module eigengene (ME)，反映了节点在模块内的隶属度。然后对特征基因高度相关的模块进行合并。<br><img src="/2023/05/22/WGCNA/P4.png"></li></ul></li><li>将模块与表型相关联：寻找有生物学意义的模块<ul><li>具有高性状显著性的模块可能代表与样本性状相关的通路。</li></ul></li><li>模块间相关性研究（Optional）</li><li>寻找模块内部的key drivers（Optional）</li></ol><p>Tips:</p><p>Scale-free network 可轻易从无标度网络中寻找到hub genes（The highest-degree nodes）</p><p><img src="/2023/05/22/WGCNA/P2.png"></p><p>官方建议删除Counts很低的基因（例如，删除所有在 90% 以上的样本中计数小于 10 的基因），因为这种低表达的Feature往往反映噪声,且基于计数的相关性大多为零并没有真正意义。实际阈值应基于实验设计、测序深度和样本计数。</p><p>无论是使用 RPKM、FPKM 还是简单的归一化计数，只要所有样本都以相同的方式处理，对 WGCNA 分析并没有太大影响。</p><p><a href="https://horvath.genetics.ucla.edu/html/CoexpressionNetwork/Rpackages/WGCNA/faq.html">WGCNA R包常见问题QA</a></p><h1 id="hdWGCNA"><a href="#hdWGCNA" class="headerlink" title="hdWGCNA"></a>hdWGCNA</h1><p><a href="https://smorabit.github.io/hdWGCNA/">github</a><br><a href="https://smorabit.github.io/hdWGCNA/articles/hdWGCNA.html">Tutorial</a></p><h2 id="1-初始化配置"><a href="#1-初始化配置" class="headerlink" title="1. 初始化配置"></a>1. 初始化配置</h2><p>注：在<em>SetupForWGCNA</em>步骤后，不建议对seurat对象进行subset（因为subset后WGCNA的输入基因可能无法代表原始的seurat对象）</p><p>gene_select参数的三种模式，选择不同的WGCNA输入基因：<br>variable: 使用Seurat对象中的高变基因<br>fraction: 使用在整个数据集或每组细胞中特定部分细胞中表达的基因，使用group.by指定。（在Demo中，我们将选择在这个数据集中至少5%的细胞中表达的基因。）<br>custom: 使用自定义列表中指定的基因。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R">seurat_obj <span class="hljs-operator">&lt;-</span> SetupForWGCNA<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  gene_select <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fraction&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># the gene selection approach</span><br>  fraction <span class="hljs-operator">=</span> <span class="hljs-number">0.05</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># fraction of cells that a gene needs to be expressed in order to be included</span><br>  wgcna_name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;tutorial&quot;</span> <span class="hljs-comment"># the name of the hdWGCNA experiment</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="2-构建metacells"><a href="#2-构建metacells" class="headerlink" title="2. 构建metacells"></a>2. 构建metacells</h2><p>初始化配置后，需要从单细胞数据集构造构建<strong>metacells（元细胞）</strong>。</p><p>由于counts矩阵的稀疏性，会导致较大的方差，导致单细胞数据直接计算Pearson基因相关性会不准确。解决这个问题的一种方法是使用<a href="https://github.com/tanaylab/metacells">metacells</a>的方法。</p><p>简单来说，<a href="https://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1812-2">元细胞</a>是源自同一sampleid的小群相似细胞的聚集体。使用k近邻(KNN)算法找到 K 个最近邻居，识别相似细胞，并将它们进行聚合，然后计算这些细胞的平均或总表达，从而产生元细胞基因表达矩阵，使用元细胞的基因表达矩阵进行下游分析（分析思路类似细胞metadata矩阵，含有对细胞的分类信息等）。与Counts矩阵相比，元细胞表达矩阵的稀疏性大大降低，并提供了对转录状态更稳健的估计。因为像WGCNA等的相关网络方法对数据稀疏性很敏感，使用元细胞作为此类分析技术的输入会更稳健、噪音更小；且在处理大数据（例如分析数百万个单个细胞）时要分析的细胞数量减少（约 100 倍）。很多单细胞表观基因组方法，如Cicero，在构建共可及性网络之前采用了类似的元细胞聚集方法。</p><p>可参考：<a href="https://divingintogeneticsandgenomics.com/post/how-to-do-gene-correlation-for-single-cell-rnaseq-data-part-2-using-meta-cell/">Tommy的blog</a></p><p>函数<em>MetacellsByGroups</em>，用于构建元细胞表达矩阵。该函数为元细胞数据集构建一个新的Seurat对象，该对象存储在hdWGCNA实验内部。该group.by参数确定将在哪些group中构造元细胞。我们只想从来自相同生物样本的细胞中构建元细胞，因此通过group.by将该信息传递给hdWGCNA至关重要。此外，我们通常为每种细胞类型分别构建元细胞。因此，在Demo中，我们按Sample和celltype进行分组，以获得期望的结果。</p><p>要聚合的单元格的数量k应该根据输入数据集的大小进行调整，通常较小的k可以用于小数据集。通常使用20到75之间的k值。Demo使用k&#x3D;25。元细胞之间允许的重叠细胞数量可以使用<em>max shared</em>参数进行调整。(这里的参数可以根据细胞数量调整k值)</p><p>注:当存在细胞数极少的细胞类型(由于极端细胞数导致代表性差的细胞类型)时，按照group.by&#x3D;celltype进行构建metacells的hdWGCNA表现不佳。例如，在Demo数据集中，脑血管细胞是细胞数最少的celltype，我们已经从这个分析中排除了它们。MetacellsByGroups有一个参数<em>min cells</em>，用于排除小于指定cell的group。如果最小cell的值过低，可能会出现错误。</p><p>hdWGCNA将group.by中所有输入的参数进行组合，形成新的metacell_grouping列，并要求每个metacell_grouping内的细胞数大于min_cells（默认值100），否则会被过滤掉。</p><p>K值的设置: <a href="https://www.ibm.com/topics/knn#:~:text=The%20k%2Dnearest%20neighbors%20algorithm%2C%20also%20known%20as%20KNN%20or,of%20an%20individual%20data%20point.">kNN</a> k值越小，方差越大，偏差越小，k值越大，偏差越大，方差越小。k的选择很大程度上取决于输入数据，因为具有更多异常值或噪声的数据可能在k值较高时表现更好。建议<strong>k值设置为奇数</strong>。hdWGCNA推荐使用20到75之间的k值。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># construct metacells  in each group</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> MetacellsByGroups<span class="hljs-punctuation">(</span><br>  seurat_obj <span class="hljs-operator">=</span> seurat_obj<span class="hljs-punctuation">,</span><br>  group.by <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;cell_type&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Sample&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># specify the columns in seurat_obj@meta.data to group by</span><br>  reduction <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;harmony&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># select the dimensionality reduction to perform KNN on</span><br>  k <span class="hljs-operator">=</span> <span class="hljs-number">25</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># nearest-neighbors parameter</span><br>  max_shared <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># maximum number of shared cells between two metacells</span><br>  ident.group <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cell_type&#x27;</span> <span class="hljs-comment"># set the Idents of the metacell seurat object</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># normalize metacell expression matrix:</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> NormalizeMetacells<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>Tips: 参数<em>ident.group</em>会改变seurat_obj@misc$tutorial$<a href="mailto:&#119;&#103;&#99;&#x6e;&#x61;&#x5f;&#109;&#101;&#x74;&#x61;&#99;&#101;&#108;&#x6c;&#x5f;&#111;&#x62;&#x6a;&#64;&#x61;&#99;&#116;&#105;&#118;&#x65;&#x2e;&#105;&#x64;&#101;&#110;&#116;">&#119;&#103;&#99;&#x6e;&#x61;&#x5f;&#109;&#101;&#x74;&#x61;&#99;&#101;&#108;&#x6c;&#x5f;&#111;&#x62;&#x6a;&#64;&#x61;&#99;&#116;&#105;&#118;&#x65;&#x2e;&#105;&#x64;&#101;&#110;&#116;</a>的分组信息。seurat_obj@misc$tutorial$wgcna_metacell_obj是构建好metacells后的metadata信息，参数<em>group.by</em>会改变metadata的行名，若输入多个<em>group.by</em>参数，比如c(“cell_type”, “Sample”)会使得行名（细胞barcodes）变为”cell_type1#Sample1_1”,”cell_type1#Sample1_2”这种格式。</p><p><em>group.by</em>输入的参数必须包含<em>ident.group</em>的输入。</p><h2 id="3-共表达网络分析"><a href="#3-共表达网络分析" class="headerlink" title="3. 共表达网络分析"></a>3. 共表达网络分析</h2><h3 id="3-1-配置表达矩阵"><a href="#3-1-配置表达矩阵" class="headerlink" title="3.1 配置表达矩阵"></a>3.1 配置表达矩阵</h3><p>这里我们指定用于网络分析的表达式矩阵。因为我们只想包含抑制性神经元这群细胞，所以我们必须在构建网络之前对表达数据进行取子集。hdWGCNA包括<em>SetDatExpr</em>函数，用于存储将用于下游网络分析的一组给定细胞的转置表达矩阵。默认情况下使用元细胞表达矩阵(使用metacells&#x3D;TRUE)，但hdWGCNA确实允许在需要时使用单细胞表达矩阵。该函数允许用户指定从哪个data slot获取表达式矩阵，例如，如果用户希望应用SCTransform而不是NormalizeData的矩阵。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R">seurat_obj <span class="hljs-operator">&lt;-</span> SetDatExpr<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  group_name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INH&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># the name of the group of interest in the group.by column</span><br>  group.by<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cell_type&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># the metadata column containing the cell type info. This same column should have also been used in MetacellsByGroups</span><br>  assay <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;RNA&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># using RNA assay</span><br>  slot <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;data&#x27;</span> <span class="hljs-comment"># using normalized data</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>同时对多个细胞类型或clusters执行共表达网络分析,需要向group_name参数传入字符向量。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">seurat_obj <span class="hljs-operator">&lt;-</span> SetDatExpr<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  group_name <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;INH&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;EX&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>  group.by<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cell_type&#x27;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="3-2-soft-Power-软阈值-设置"><a href="#3-2-soft-Power-软阈值-设置" class="headerlink" title="3.2 soft-Power(软阈值)设置"></a>3.2 soft-Power(软阈值)设置</h3><p>WGCNA将相关性矩阵转化为邻接矩阵（给相关性进行幂次计算，使得基因间的连通性符合幂率分布规律）。选择合适的软阈值以减少相关矩阵中存在的噪声量，从而保留强连接并去除弱连接。</p><p>函数<em>TestSoftPowers</em>执行不同软阈值的参数扫描。该函数通过对不同power值的网络拓扑情况进行检查，帮助我们在构建共表达网络时指导选择软实力阈值。共同表达网络应该具有无标度的拓扑结构，因此TestSoftPowers函数对不同软阈值下共表达网络与无标度图的相似程度进行建模。此外，我们还包含了一个函数<em>PlotSoftPowers</em>来可视化参数扫描的结果。</p><p>此步骤的networkType的参数设置和图像输出与WGCNA相似。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># Test different soft powers:</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> TestSoftPowers<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  networkType <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;signed&#x27;</span> <span class="hljs-comment"># you can also use &quot;unsigned&quot; or &quot;signed hybrid&quot;</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plot the results:</span><br>plot_list <span class="hljs-operator">&lt;-</span> PlotSoftPowers<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># assemble with patchwork</span><br>wrap_plots<span class="hljs-punctuation">(</span>plot_list<span class="hljs-punctuation">,</span> ncol<span class="hljs-operator">=</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/P5.png"></p><ul><li>Scale independence, 该图的点的纵坐标越高，越接近scale free network。<strong>纵坐标需要大于等于 0.8 才认为该网络是无标度拓扑模型。</strong></li><li>Mean Connectivity, Median Connectivity, Max Connectivity: 由于在scale free network中，大多数节点的连通性较差，因此这三个指标越低，越接近scale free network。</li></ul><p>如果用户没有提供软阈值，则<em>ConstructNetwork</em>将自动选择软阈值。软阈值参数扫描的输出表可以使用<em>GetPowerTable</em>函数查看</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">power_table <span class="hljs-operator">&lt;-</span> GetPowerTable<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br>head<span class="hljs-punctuation">(</span>power_table<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="3-3-构建共表达网络"><a href="#3-3-构建共表达网络" class="headerlink" title="3.3 构建共表达网络"></a>3.3 构建共表达网络</h3><p>使用hdWGCNA函数<em>ConstructNetwork</em>，它在底层调用WGCNA包的<em>blockwiseConsensusModules</em>函数。<em>blockwiseConsensusModules</em>的参数可以用相同的参数名直接传递给ConstructNetwork。下面的代码使用上面选择的软阈值来构建共表达网络。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># construct co-expression network:</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ConstructNetwork<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span> soft_power<span class="hljs-operator">=</span><span class="hljs-number">9</span><span class="hljs-punctuation">,</span><br>  setDatExpr<span class="hljs-operator">=</span><span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span><br>  tom_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;INH&#x27;</span> <span class="hljs-comment"># name of the topoligical overlap matrix written to disk</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>函数<em>plotdendprogram</em>用于可视化WGCNA树状图，该图用于显示由网络分析产生的不同共表达模块。树状图上的每片叶子代表一个基因，底部的颜色表示共表达模块分配。<strong>与WGCNA相同，灰色模块由不属于任何共表达模块的基因组成。对于所有下游分析和解释，应该忽略灰色模块。</strong></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">PlotDendrogram<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> main<span class="hljs-operator">=</span><span class="hljs-string">&#x27;INH hdWGCNA Dendrogram&#x27;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/P6.png"></p><p>3.4 topoligcal overlap matrix (TOM) 图<br>hdWGCNA将共表达网络表示为topoligcal overlap matrix (TOM)。这是一个基因对基因的方阵，其中每个值都是基因之间的拓扑重叠。当运行ConstructNetwork时，TOM被写入seurat对象，我们可以使用GetTOM函数将其加载到R中。高级用户可能希望检查TOM以进行自定义下游分析。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">TOM <span class="hljs-operator">&lt;-</span> GetTOM<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="4-模块特征基因与连通性"><a href="#4-模块特征基因与连通性" class="headerlink" title="4. 模块特征基因与连通性"></a>4. 模块特征基因与连通性</h2><h3 id="4-1-计算模块特征基因"><a href="#4-1-计算模块特征基因" class="headerlink" title="4.1 计算模块特征基因"></a>4.1 计算模块特征基因</h3><p>Module Eigengenes (MEs，模块特征基因)是一种用于度量整个共表达模块的基因表达谱的方式。简而言之，通过对包含每个模块的基因表达矩阵的子集执行(PCA)来计算模块特征基因。每个PCA矩阵的第一个PC是MEs。直观地说，它是一个“被合成的基因”，它是该模块中所有基因的最佳代表。</p><p>函数<em>ModuleEigengenes</em>用于计算单个细胞中的模块特征基因。此外，我们允许用户对MEs应用Harmony批量校正，从而产生harmonized module eigengenes(hMEs)。下面的代码使用group.by.vars参数执行由基于Sampleid进行Harmony的模块特征基因计算。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># need to run ScaleData first or else harmony throws an error:</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ScaleData<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> features<span class="hljs-operator">=</span>VariableFeatures<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># compute all MEs in the full single-cell dataset</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ModuleEigengenes<span class="hljs-punctuation">(</span><br> seurat_obj<span class="hljs-punctuation">,</span><br> group.by.vars<span class="hljs-operator">=</span><span class="hljs-string">&quot;Sample&quot;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>ME矩阵存储为矩阵，其中每行是一个细胞，每列是一个模块。可以使用<em>GetMEs</em>函数从Seurat对象中提取该矩阵，该函数在默认检索<strong>hMEs</strong>。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># harmonized module eigengenes:</span><br>hMEs <span class="hljs-operator">&lt;-</span> GetMEs<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># module eigengenes:</span><br>MEs <span class="hljs-operator">&lt;-</span> GetMEs<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> harmonized<span class="hljs-operator">=</span><span class="hljs-literal">FALSE</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="4-2-计算连通性"><a href="#4-2-计算连通性" class="headerlink" title="4.2 计算连通性"></a>4.2 计算连通性</h3><p>在共表达网络分析中，我们通常希望关注hub-gene，即在每个模块中连通性最高的基因。因此，我们希望<strong>确定每个基因的基于MEs的连通性，也称为kME</strong>。hdWGCNA使用<em>ModuleConnectivity</em>函数来计算完整的单细胞数据集中的kME值，而不是元细胞数据集。</p><p>这个函数本质上计算基因和模块特征基因之间的两两相关性。可以为数据集中的所有细胞计算kME，但我们建议在运行ConstructNetwork后的celltype或group中计算kME。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># compute eigengene-based connectivity (kME):</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ModuleConnectivity<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  group.by <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cell_type&#x27;</span><span class="hljs-punctuation">,</span> group_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;INH&#x27;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>可以根据模块具体的生物学意义对模块进行重命名。<br><a href="https://smorabit.github.io/hdWGCNA/articles/customization.html">模块重命名说明书</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># rename the modules</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ResetModuleNames<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  new_name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INH-M&quot;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>我们可以使用<em>PlotKMEs</em>函数可视化每个模块中按kME排序的基因。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># plot genes ranked by kME for each module</span><br>p <span class="hljs-operator">&lt;-</span> PlotKMEs<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> ncol<span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><br><br>p<br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/P7.png"></p><h3 id="4-3-获取模块分配表"><a href="#4-3-获取模块分配表" class="headerlink" title="4.3 获取模块分配表"></a>4.3 获取模块分配表</h3><p>hdWGCNA允许使用<em>GetModules</em>函数轻松访问模块分配表。</p><p>该表由三列组成:geneID，存储该基因的模块，模块颜色，这在许多下游绘图步骤中使用。如果调用<em>ModuleConnectivity</em>函数，则会为模块分配表添加额外的kME列。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># get the module assignment table:</span><br>modules <span class="hljs-operator">&lt;-</span> GetModules<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># show the first 6 columns:</span><br>head<span class="hljs-punctuation">(</span>modules<span class="hljs-punctuation">[</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">6</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/P8.png"></p><p>到此为止是hdWGCNA的主体分析流程，记得保存结果。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">saveRDS<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> file<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hdWGCNA_object.rds&#x27;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="4-4-计算hub-gene打分"><a href="#4-4-计算hub-gene打分" class="headerlink" title="4.4 计算hub-gene打分"></a>4.4 计算hub-gene打分</h3><p>Gene scoring是单细胞转录组学中一种常见的方法，用于计算一组基因的总体特征得分。Seurat使用<em>AddModuleScore</em>函数进行打分，但也有其他方法，如UCell。hdWGCNA使用<em>ModuleExprScore</em>函数，用于计算每个模块给定数量的基因的基因分数，基于Seurat或UCell算法。基因评分是通过计算模块特征基因来展示模块表达情况的另一种方法。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># compute gene scoring for the top 25 hub genes by kME for each module</span><br><span class="hljs-comment"># with Seurat method</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ModuleExprScore<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  n_genes <span class="hljs-operator">=</span> <span class="hljs-number">25</span><span class="hljs-punctuation">,</span><br>  method<span class="hljs-operator">=</span><span class="hljs-string">&#x27;Seurat&#x27;</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># compute gene scoring for the top 25 hub genes by kME for each module</span><br><span class="hljs-comment"># with UCell method</span><br>library<span class="hljs-punctuation">(</span>UCell<span class="hljs-punctuation">)</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ModuleExprScore<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  n_genes <span class="hljs-operator">=</span> <span class="hljs-number">25</span><span class="hljs-punctuation">,</span><br>  method<span class="hljs-operator">=</span><span class="hljs-string">&#x27;UCell&#x27;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="5-使用Seurat进行基础的下游可视化"><a href="#5-使用Seurat进行基础的下游可视化" class="headerlink" title="5. 使用Seurat进行基础的下游可视化"></a>5. 使用Seurat进行基础的下游可视化</h2><h3 id="Featureplot"><a href="#Featureplot" class="headerlink" title="Featureplot"></a>Featureplot</h3><p><em>ModuleFeaturePlot</em>函数，用于为每个共表达模块构建由每个模块指定的唯一颜色着色的featureplot</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># make a featureplot of hMEs for each module</span><br>plot_list <span class="hljs-operator">&lt;-</span> ModuleFeaturePlot<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  features<span class="hljs-operator">=</span><span class="hljs-string">&#x27;hMEs&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># plot the hMEs</span><br>  order<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span> <span class="hljs-comment"># order so the points with highest hMEs are on top</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># stitch together with patchwork</span><br>wrap_plots<span class="hljs-punctuation">(</span>plot_list<span class="hljs-punctuation">,</span> ncol<span class="hljs-operator">=</span><span class="hljs-number">6</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/P9.png"></p><p>可以使用相同的函数绘制hub-gene的打分情况</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># make a featureplot of hub scores for each module</span><br>plot_list <span class="hljs-operator">&lt;-</span> ModuleFeaturePlot<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  features<span class="hljs-operator">=</span><span class="hljs-string">&#x27;scores&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># plot the hub gene scores</span><br>  order<span class="hljs-operator">=</span><span class="hljs-string">&#x27;shuffle&#x27;</span> <span class="hljs-comment"># order so cells are shuffled</span><br>  ucell <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span> <span class="hljs-comment"># depending on Seurat vs UCell for gene scoring</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># stitch together with patchwork</span><br>wrap_plots<span class="hljs-punctuation">(</span>plot_list<span class="hljs-punctuation">,</span> ncol<span class="hljs-operator">=</span><span class="hljs-number">6</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/ME_featureplot_scores.png"></p><h3 id="模块相关性"><a href="#模块相关性" class="headerlink" title="模块相关性"></a>模块相关性</h3><p><em>ModuleCorrelogram</em>函数，可以使用R包corrplot根据每个模块的hMEs, MEs或hub基因评分来可视化每个模块之间的相关性。函数默认使用的是hMEs。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># plot module correlagram</span><br>ModuleCorrelogram<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/ME_correlogram.png"></p><h3 id="DotPlot"><a href="#DotPlot" class="headerlink" title="DotPlot"></a>DotPlot</h3><p>将hMEs数据添加到metadata中进行绘制</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># get hMEs from seurat object</span><br>MEs <span class="hljs-operator">&lt;-</span> GetMEs<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> harmonized<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><br>mods <span class="hljs-operator">&lt;-</span> colnames<span class="hljs-punctuation">(</span>MEs<span class="hljs-punctuation">)</span>; mods <span class="hljs-operator">&lt;-</span> mods<span class="hljs-punctuation">[</span>mods <span class="hljs-operator">!=</span> <span class="hljs-string">&#x27;grey&#x27;</span><span class="hljs-punctuation">]</span><br><br><span class="hljs-comment"># add hMEs to Seurat meta-data:</span><br>seurat_obj<span class="hljs-operator">@</span>meta.data <span class="hljs-operator">&lt;-</span> cbind<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-operator">@</span>meta.data<span class="hljs-punctuation">,</span> MEs<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#绘制dotplot</span><br><span class="hljs-comment"># plot with Seurat&#x27;s DotPlot function</span><br>p <span class="hljs-operator">&lt;-</span> DotPlot<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span> features<span class="hljs-operator">=</span>mods<span class="hljs-punctuation">,</span> group.by <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cell_type&#x27;</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># flip the x/y axes, rotate the axis labels, and change color scheme:</span><br>p <span class="hljs-operator">&lt;-</span> p <span class="hljs-operator">+</span><br>  coord_flip<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  RotatedAxis<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  scale_color_gradient2<span class="hljs-punctuation">(</span>high<span class="hljs-operator">=</span><span class="hljs-string">&#x27;red&#x27;</span><span class="hljs-punctuation">,</span> mid<span class="hljs-operator">=</span><span class="hljs-string">&#x27;grey95&#x27;</span><span class="hljs-punctuation">,</span> low<span class="hljs-operator">=</span><span class="hljs-string">&#x27;blue&#x27;</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plot output</span><br>p<br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/ME_dootploot.png"></p><h3 id="Vlnplot"><a href="#Vlnplot" class="headerlink" title="Vlnplot"></a>Vlnplot</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># Plot INH-M4 hME using Seurat VlnPlot function</span><br>p <span class="hljs-operator">&lt;-</span> VlnPlot<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  features <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;INH-M12&#x27;</span><span class="hljs-punctuation">,</span><br>  group.by <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cell_type&#x27;</span><span class="hljs-punctuation">,</span><br>  pt.size <span class="hljs-operator">=</span> <span class="hljs-number">0</span> <span class="hljs-comment"># don&#x27;t show actual data points</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># add box-and-whisker plots on top:</span><br>p <span class="hljs-operator">&lt;-</span> p <span class="hljs-operator">+</span> geom_boxplot<span class="hljs-punctuation">(</span>width<span class="hljs-operator">=</span><span class="hljs-number">.25</span><span class="hljs-punctuation">,</span> fill<span class="hljs-operator">=</span><span class="hljs-string">&#x27;white&#x27;</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># change axis labels and remove legend:</span><br>p <span class="hljs-operator">&lt;-</span> p <span class="hljs-operator">+</span> xlab<span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> ylab<span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;hME&#x27;</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> NoLegend<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plot output</span><br>p<br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/ME_vlnplot.png"></p><h2 id="6-网络分析"><a href="#6-网络分析" class="headerlink" title="6. 网络分析"></a>6. 网络分析</h2><p><a href="https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html">链接</a></p><p>加载环境</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># single-cell analysis package</span><br>library<span class="hljs-punctuation">(</span>Seurat<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plotting and data science packages</span><br>library<span class="hljs-punctuation">(</span>tidyverse<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>cowplot<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>patchwork<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># co-expression network analysis packages:</span><br>library<span class="hljs-punctuation">(</span>WGCNA<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>hdWGCNA<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># network analysis &amp; visualization package:</span><br>library<span class="hljs-punctuation">(</span>igraph<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># using the cowplot theme for ggplot</span><br>theme_set<span class="hljs-punctuation">(</span>theme_cowplot<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># set random seed for reproducibility</span><br>set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># load the Zhou et al snRNA-seq dataset</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> readRDS<span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;data/Zhou_control.rds&#x27;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="为每个模块生成单独的网络图"><a href="#为每个模块生成单独的网络图" class="headerlink" title="为每个模块生成单独的网络图"></a>为每个模块生成单独的网络图</h3><p><em>ModuleNetworkPlot</em>显示每个模块的单独网络图，按kME显示前25个基因。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs R">ModuleNetworkPlot<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/INH-M12.png"></p><p>在该网络中，每个节点代表一个基因，每条边代表网络中两个基因的共表达关系。每个模块网络图都是根据hdWGCNA模块分配表GetModules(seurat obj)中的颜色列进行着色的。kME排名前10位的枢纽基因位于图的中心，其余15个基因位于外圈。</p><p>可调节参数美化图片:</p><ul><li>edge.alpha：确定网络边缘的不透明度</li><li>vertex.size：确定节点的大小</li><li>vertex.label.cex：确定基因标签的字体尺寸</li></ul><h3 id="可视化由每个模块给定数量的hub-gens组成的网络"><a href="#可视化由每个模块给定数量的hub-gens组成的网络" class="headerlink" title="可视化由每个模块给定数量的hub-gens组成的网络"></a>可视化由每个模块给定数量的hub-gens组成的网络</h3><p><em>HubGeneNetworkPlot</em>可视化由每个模块给定数量的中心基因的所有模块组成的网络。该函数取用户指定的前n个枢纽基因和其他随机选择的基因，采用<a href="https://en.wikipedia.org/wiki/Force-directed_graph_drawing">force-directed graph drawing algorithm 力导向布局算法</a>构建一个联合网络。</p><p>为了视觉清晰度，可以使用edge prop参数对网络中的边的数量进行下采样。在下面的例子中，我们将每个模块的前3个hub-gene和其他6个基因可视化。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># hubgene network</span><br>HubGeneNetworkPlot<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  n_hubs <span class="hljs-operator">=</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span> n_other<span class="hljs-operator">=</span><span class="hljs-number">5</span><span class="hljs-punctuation">,</span><br>  edge_prop <span class="hljs-operator">=</span> <span class="hljs-number">0.75</span><span class="hljs-punctuation">,</span><br>  mods <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;all&#x27;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/hub_net.png"></p><p>每个节点代表一个基因，每个边代表一个共表达关系。在该网络中，我们用模块的颜色对模块内的边上色，对模块间的边上色。该网络中边缘的不透明度由共表达关系的强度来定义。附加的网络布局设置可以传递给图中<em>layout_with_fr</em>函数。用户还可以通过指定<em>return graph &#x3D; TRUE</em>来返回要绘图的igraph对象。</p><p>g &lt;- HubGeneNetworkPlot(seurat_obj,  return_graph&#x3D;TRUE)</p><h4 id="使用Umap同时可视化共表达中的所有基因"><a href="#使用Umap同时可视化共表达中的所有基因" class="headerlink" title="使用Umap同时可视化共表达中的所有基因"></a>使用Umap同时可视化共表达中的所有基因</h4><p><em>ModuleUMAPPlot</em>函数使用UMAP降维算法同时可视化共表达中的所有基因。</p><p>hdWGCNA包含<em>RunModuleUMAP</em>函数，基于TOM矩阵运行UMAP算法。对于UMAP分析，我们将TOM中的列子集设置为仅包含每个模块按kME排列的前n个中心基因，n由用户指定。因此，每个基因在UMAP空间中的位置取决于该基因与hub-gene的连通性。该函数利用了uwot R包中的UMAP实现，因此uwot:: UMAP函数的附加UMAP参数(如min dist或spread)可以在RunModuleUMAP中使用。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs R">seurat_obj <span class="hljs-operator">&lt;-</span> RunModuleUMAP<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  n_hubs <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># number of hub genes to include for the UMAP embedding</span><br>  n_neighbors<span class="hljs-operator">=</span><span class="hljs-number">15</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># neighbors parameter for UMAP</span><br>  min_dist<span class="hljs-operator">=</span><span class="hljs-number">0.1</span> <span class="hljs-comment"># min distance between points in UMAP space</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#可视化</span><br><span class="hljs-comment"># get the hub gene UMAP table from the seurat object</span><br>umap_df <span class="hljs-operator">&lt;-</span> GetModuleUMAP<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plot with ggplot</span><br>ggplot<span class="hljs-punctuation">(</span>umap_df<span class="hljs-punctuation">,</span> aes<span class="hljs-punctuation">(</span>x<span class="hljs-operator">=</span>UMAP1<span class="hljs-punctuation">,</span> y<span class="hljs-operator">=</span>UMAP2<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  geom_point<span class="hljs-punctuation">(</span><br>   color<span class="hljs-operator">=</span>umap_df<span class="hljs-operator">$</span>color<span class="hljs-punctuation">,</span> <span class="hljs-comment"># color each point by WGCNA module</span><br>   size<span class="hljs-operator">=</span>umap_df<span class="hljs-operator">$</span>kME<span class="hljs-operator">*</span><span class="hljs-number">2</span> <span class="hljs-comment"># size of each point based on intramodular connectivity</span><br>  <span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  umap_theme<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/hubgene_umap.png"></p><p>在这个图中，每个点代表一个基因。每个点的大小按其指定模块的基因的kME进行缩放。可以使用<strong>ModuleUMAPPlot</strong>函数来绘制基因及其共表达关系，并可视化模块UMAP中的基因（但并未可视化底层网络。）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R">ModuleUMAPPlot<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  edge.alpha<span class="hljs-operator">=</span><span class="hljs-number">0.25</span><span class="hljs-punctuation">,</span><br>  sample_edges<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span><br>  edge_prop<span class="hljs-operator">=</span><span class="hljs-number">0.1</span><span class="hljs-punctuation">,</span> <span class="hljs-comment"># proportion of edges to sample (20% here)</span><br>  label_hubs<span class="hljs-operator">=</span><span class="hljs-number">2</span> <span class="hljs-punctuation">,</span><span class="hljs-comment"># how many hub genes to plot per module?</span><br>  keep_grey_edges<span class="hljs-operator">=</span><span class="hljs-literal">FALSE</span><br><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/hubgene_umap_igraph.png"></p><p>这张图与我们用ggplot2绘制的图相似，但我们展示了共表达网络，并在每个模块中标记了2个hub-gene。为了视觉清晰度，我们使用edge prop参数下采样，只保留该网络中20%的边。我们还允许用户返回igraph对象来制作他们自己的自定义图或执行下游网络分析.</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#这个图可以优化，虽然只标记了两个hub gene，但仍然存在基因重叠现象</span><br>g <span class="hljs-operator">&lt;-</span> ModuleUMAPPlot<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">,</span>  return_graph<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="可视化改变hub-gene的数量对uamp的影响"><a href="#可视化改变hub-gene的数量对uamp的影响" class="headerlink" title="可视化改变hub-gene的数量对uamp的影响"></a>可视化改变hub-gene的数量对uamp的影响</h3><p>我们在UMAP计算中包含的hub-gene的数量会影响下游可视化。在这里，我们使用gganimate来直观地比较用不同数量的hub-gene计算的umap。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># different label weights to test</span><br>n_hubs <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <span class="hljs-number">1</span><span class="hljs-operator">:</span><span class="hljs-number">10</span><span class="hljs-operator">*</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># loop through different weights</span><br>df <span class="hljs-operator">&lt;-</span> data.frame<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br><span class="hljs-keyword">for</span><span class="hljs-punctuation">(</span>cur_hubs <span class="hljs-keyword">in</span> n_hubs<span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><br><br>  <span class="hljs-comment"># make a module UMAP using different label weights</span><br>  seurat_obj <span class="hljs-operator">&lt;-</span> RunModuleUMAP<span class="hljs-punctuation">(</span><br>    seurat_obj<span class="hljs-punctuation">,</span><br>    n_hubs <span class="hljs-operator">=</span> cur_hubs<span class="hljs-punctuation">,</span><br>    n_neighbors<span class="hljs-operator">=</span><span class="hljs-number">15</span><span class="hljs-punctuation">,</span><br>    exclude_grey <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">,</span><br>    min_dist<span class="hljs-operator">=</span><span class="hljs-number">0.1</span><br>  <span class="hljs-punctuation">)</span><br><br>  <span class="hljs-comment"># add to ongoing dataframe</span><br>  cur_df <span class="hljs-operator">&lt;-</span> GetModuleUMAP<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br>  cur_df<span class="hljs-operator">$</span>n_hubs <span class="hljs-operator">&lt;-</span> cur_hubs<br>  df <span class="hljs-operator">&lt;-</span> rbind<span class="hljs-punctuation">(</span>df<span class="hljs-punctuation">,</span> cur_df<span class="hljs-punctuation">)</span><br><span class="hljs-punctuation">&#125;</span><br><br><span class="hljs-comment"># ggplot animation library</span><br>library<span class="hljs-punctuation">(</span>gganimate<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plot with ggplot + gganimate</span><br>p <span class="hljs-operator">&lt;-</span> ggplot<span class="hljs-punctuation">(</span>df<span class="hljs-punctuation">,</span> aes<span class="hljs-punctuation">(</span>x<span class="hljs-operator">=</span>UMAP1<span class="hljs-punctuation">,</span> y<span class="hljs-operator">=</span>UMAP2<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  geom_point<span class="hljs-punctuation">(</span>color<span class="hljs-operator">=</span>df<span class="hljs-operator">$</span>color<span class="hljs-punctuation">,</span> size<span class="hljs-operator">=</span>df<span class="hljs-operator">$</span>kME<span class="hljs-operator">*</span><span class="hljs-number">2</span> <span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  ggtitle<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;N hubs: &#123;closest_state&#125;&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  transition_states<span class="hljs-punctuation">(</span><br>    n_hubs<span class="hljs-punctuation">,</span><br>    transition_length <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    state_length <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    wrap <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><br>  <span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  view_follow<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  enter_fade<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span><br>  umap_theme<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br><br>animate<span class="hljs-punctuation">(</span>p<span class="hljs-punctuation">,</span> fps<span class="hljs-operator">=</span><span class="hljs-number">30</span><span class="hljs-punctuation">,</span> duration<span class="hljs-operator">=</span><span class="hljs-number">25</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/hub_umap.gif"></p><h3 id="有监督的Umap-略"><a href="#有监督的Umap-略" class="headerlink" title="有监督的Umap,略"></a><a href="https://smorabit.github.io/hdWGCNA/articles/network_visualizations.html">有监督的Umap,略</a></h3><h2 id="7-Differential-module-eigengene-DME-analysis"><a href="#7-Differential-module-eigengene-DME-analysis" class="headerlink" title="7. Differential module eigengene (DME) analysis"></a>7. Differential module eigengene (DME) analysis</h2><p>执行差异模块特征基因(DME)分析，揭示在给定group中上调或下调的模块。</p><p>首先加载环境</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># single-cell analysis package</span><br>library<span class="hljs-punctuation">(</span>Seurat<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># plotting and data science packages</span><br>library<span class="hljs-punctuation">(</span>tidyverse<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>cowplot<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>patchwork<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>ggrepel<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># co-expression network analysis packages:</span><br>library<span class="hljs-punctuation">(</span>WGCNA<span class="hljs-punctuation">)</span><br>library<span class="hljs-punctuation">(</span>hdWGCNA<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># using the cowplot theme for ggplot</span><br>theme_set<span class="hljs-punctuation">(</span>theme_cowplot<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># set random seed for reproducibility</span><br>set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">12345</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># re-load the Zhou et al snRNA-seq dataset processed with hdWGCNA</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> readRDS<span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;Zhou_2020_hdWGCNA.rds&#x27;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="两组比较"><a href="#两组比较" class="headerlink" title="两组比较"></a>两组比较</h3><p>这里我们讨论如何在两个不同的组之间执行DME测试。使用hdWGCNA函数<em>FindDMEs</em>，这是Seurat函数FindMarkers的一个特例。使用Wilcoxon test，来比较两组，但其他test可以通过test.use参数调用。</p><p>由于教程数据集只包含对照大脑样本，我们将使用性别来定义我们的两个group。<em>FindDMEs</em>需要group1和group2的barcodes列表。此外，我们将只比较来自INH clusters的细胞，因为我们对INH clusters执行了网络分析。</p><h4 id="首先获取group1和group2的barcodes列表"><a href="#首先获取group1和group2的barcodes列表" class="headerlink" title="首先获取group1和group2的barcodes列表"></a>首先获取group1和group2的barcodes列表</h4><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R">group1 <span class="hljs-operator">&lt;-</span> seurat_obj<span class="hljs-operator">@</span>meta.data <span class="hljs-operator">%&gt;%</span> subset<span class="hljs-punctuation">(</span>cell_type <span class="hljs-operator">==</span> <span class="hljs-string">&#x27;INH&#x27;</span> <span class="hljs-operator">&amp;</span> msex <span class="hljs-operator">==</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span> rownames<br>group2 <span class="hljs-operator">&lt;-</span> seurat_obj<span class="hljs-operator">@</span>meta.data <span class="hljs-operator">%&gt;%</span> subset<span class="hljs-punctuation">(</span>cell_type <span class="hljs-operator">==</span> <span class="hljs-string">&#x27;INH&#x27;</span> <span class="hljs-operator">&amp;</span> msex <span class="hljs-operator">!=</span> <span class="hljs-number">0</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span> rownames<br><br>head<span class="hljs-punctuation">(</span>group1<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>执行<em>FindDMEs</em></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs R">DMEs <span class="hljs-operator">&lt;-</span> FindDMEs<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  barcodes1 <span class="hljs-operator">=</span> group1<span class="hljs-punctuation">,</span><br>  barcodes2 <span class="hljs-operator">=</span> group2<span class="hljs-punctuation">,</span><br>  test.use<span class="hljs-operator">=</span><span class="hljs-string">&#x27;wilcox&#x27;</span><span class="hljs-punctuation">,</span><br>  wgcna_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tutorial&#x27;</span><br><span class="hljs-punctuation">)</span><br><br>head<span class="hljs-punctuation">(</span>DMEs<span class="hljs-punctuation">)</span><br><br><br>p_val  avg_log2FC pct.1 pct.2    p_val_adj  module<br>INH<span class="hljs-operator">-</span>M18 <span class="hljs-number">4.714924e-23</span>  <span class="hljs-number">0.40637874</span> <span class="hljs-number">0.894</span> <span class="hljs-number">0.729</span> <span class="hljs-number">8.486863e-22</span> INH<span class="hljs-operator">-</span>M18<br>INH<span class="hljs-operator">-</span>M16 <span class="hljs-number">5.257311e-08</span> <span class="hljs-operator">-</span><span class="hljs-number">0.18257946</span> <span class="hljs-number">0.850</span> <span class="hljs-number">0.935</span> <span class="hljs-number">9.463160e-07</span> INH<span class="hljs-operator">-</span>M16<br>INH<span class="hljs-operator">-</span>M2  <span class="hljs-number">7.565615e-05</span> <span class="hljs-operator">-</span><span class="hljs-number">0.18746938</span> <span class="hljs-number">0.661</span> <span class="hljs-number">0.738</span> <span class="hljs-number">1.361811e-03</span>  INH<span class="hljs-operator">-</span>M2<br>INH<span class="hljs-operator">-</span>M15 <span class="hljs-number">1.496899e-03</span> <span class="hljs-operator">-</span><span class="hljs-number">0.06603535</span> <span class="hljs-number">0.969</span> <span class="hljs-number">0.977</span> <span class="hljs-number">2.694417e-02</span> INH<span class="hljs-operator">-</span>M15<br>INH<span class="hljs-operator">-</span>M10 <span class="hljs-number">1.513458e-02</span> <span class="hljs-operator">-</span><span class="hljs-number">0.07774661</span> <span class="hljs-number">0.975</span> <span class="hljs-number">0.980</span> <span class="hljs-number">2.724224e-01</span> INH<span class="hljs-operator">-</span>M10<br>INH<span class="hljs-operator">-</span>M17 <span class="hljs-number">2.034644e-02</span>  <span class="hljs-number">0.24035946</span> <span class="hljs-number">0.589</span> <span class="hljs-number">0.557</span> <span class="hljs-number">3.662360e-01</span> INH<span class="hljs-operator">-</span>M17<br></code></pre></td></tr></table></figure><h4 id="使用函数PlotDMEsLollipop对结果可视化"><a href="#使用函数PlotDMEsLollipop对结果可视化" class="headerlink" title="使用函数PlotDMEsLollipop对结果可视化"></a>使用函数<em>PlotDMEsLollipop</em>对结果可视化</h4><p><a href="https://cran.r-project.org/web/packages/forestploter/vignettes/forestploter-intro.html">森林图绘制</a></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#这个图可以优化一下，有点丑</span><br>PlotDMEsLollipop<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span> <br>  DMEs<span class="hljs-punctuation">,</span> <br>  wgcna_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tutorial&#x27;</span><span class="hljs-punctuation">,</span> <br>  pvalue <span class="hljs-operator">=</span> <span class="hljs-string">&quot;p_val_adj&quot;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/test_DME_lollipop.png"></p><p>该图显示了每个模块的fold change，每个点的大小对应于该模块中基因的数量, X表示该点没有达到统计显著性。</p><p>对于PlotDMEsLollipop，如果我们在DMEs的data frame中有其他自定义列，我们可以使用group.by为一个比较组或用于绘图的比较组列表提供列名和比较参数。例如:</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs R">PlotDMEslollipop<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span> <br>  DMEs<span class="hljs-punctuation">,</span> <br>  wgcna_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;tutorial&#x27;</span><span class="hljs-punctuation">,</span> <br>  group.by <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Comparisons&quot;</span><span class="hljs-punctuation">,</span> <br>  comparison <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;group1_vs_control&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;group2_vs_control&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>  <br>  pvalue <span class="hljs-operator">=</span> <span class="hljs-string">&quot;p_val_adj&quot;</span><br><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><h4 id="使用函数PlotDMEsVolcano将结果可视化。"><a href="#使用函数PlotDMEsVolcano将结果可视化。" class="headerlink" title="使用函数PlotDMEsVolcano将结果可视化。"></a>使用函数<em>PlotDMEsVolcano</em>将结果可视化。</h4><p>使用<strong>PlotDMEsVolcano</strong>来制作火山图，以显示fold change和显著性水平。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R">PlotDMEsVolcano<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  DMEs<span class="hljs-punctuation">,</span><br>  wgcna_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tutorial&#x27;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="一对多的DME分析"><a href="#一对多的DME分析" class="headerlink" title="一对多的DME分析"></a>一对多的DME分析</h3><p>与Seurat函数FindAllMarkers类似，在指定要分组cell的列时，可以使用函数<strong>FindAllDMEs</strong>执行单对全的DME测试。我们在这里分组。通过每个细胞类型进行一对一的测试。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R">group.by <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cell_type&#x27;</span><br><br>DMEs_all <span class="hljs-operator">&lt;-</span> FindAllDMEs<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  group.by <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;cell_type&#x27;</span><span class="hljs-punctuation">,</span><br>  wgcna_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tutorial&#x27;</span><br><span class="hljs-punctuation">)</span><br><br>head<span class="hljs-punctuation">(</span>DMEs_all<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>绘图</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs R">p <span class="hljs-operator">&lt;-</span> PlotDMEsVolcano<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  DMEs_all<span class="hljs-punctuation">,</span><br>  wgcna_name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;tutorial&#x27;</span><span class="hljs-punctuation">,</span><br>  plot_labels<span class="hljs-operator">=</span><span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span><br>  show_cutoff<span class="hljs-operator">=</span><span class="hljs-literal">FALSE</span><br><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># facet wrap by each cell type</span><br>p <span class="hljs-operator">+</span> facet_wrap<span class="hljs-punctuation">(</span><span class="hljs-operator">~</span>group<span class="hljs-punctuation">,</span> ncol<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/test_DME_volcano2.png"></p><h2 id="8-模块特征相关性分析"><a href="#8-模块特征相关性分析" class="headerlink" title="8.模块特征相关性分析"></a>8.模块特征相关性分析</h2><h3 id="计算相关性"><a href="#计算相关性" class="headerlink" title="计算相关性"></a>计算相关性</h3><p>使用函数<em>ModuleTraitCorrelation</em>将选定的变量与模块特征基因相关联。该函数计算指定分组的相关性，因为我们可以预期某些变量可能与分组中的某些模块相关，但与其他单元组中的模块无关。在这里要注意输入变量的数据类型：</p><p>可以使用的变量包括：</p><ul><li>数值变量</li><li>只有 2 个类别的分类变量，例如“CONTROL”和“CASE”。</li><li>具有levels的分类变量，数据格式需要为因子型数据。例如，您可能有一个“疾病阶段”类别，按“健康”、“阶段 1”、“阶段 2”、“阶段 3”等排序。</li></ul><p>不能使用的变量：</p><p>具有两个以上无排序的分类变量。比如“sampleid”变量，由于这个变量的排序不一定有生物学意义，因此这样的变量不适合模块性状相关分析。再举个例子：假设有一个由三种转基因小鼠品系和一种对照小鼠组成的数据集。由于没法对这个分类进行排序，在运行相关性之前，必须将分类变量转换为数字，因此最终会得到完全没有生物学意义的相关性。在这种情况下，应该分别在对照和每个转基因小鼠品系之间建立成对的相关性比较。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># convert sex to factor </span><br>seurat_obj<span class="hljs-operator">$</span>msex <span class="hljs-operator">&lt;-</span> as.factor<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-operator">$</span>msex<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># convert age_death to numeric</span><br>seurat_obj<span class="hljs-operator">$</span>age_death <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">as.numeric</span><span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-operator">$</span>age_death<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment"># list of traits to correlate，检测模块与&#x27;braaksc&#x27;, &#x27;pmi&#x27;, &#x27;msex&#x27;, &#x27;age_death&#x27;, &#x27;doublet_scores&#x27;, &#x27;nCount_RNA&#x27;, &#x27;nFeature_RNA&#x27;, &#x27;total_counts_mt&#x27;的相关性</span><br>cur_traits <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&#x27;braaksc&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;pmi&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;msex&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;age_death&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;doublet_scores&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;nCount_RNA&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;nFeature_RNA&#x27;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&#x27;total_counts_mt&#x27;</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#按照cell_type对图片进行分面</span><br>seurat_obj <span class="hljs-operator">&lt;-</span> ModuleTraitCorrelation<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  traits <span class="hljs-operator">=</span> cur_traits<span class="hljs-punctuation">,</span><br>  group.by<span class="hljs-operator">=</span><span class="hljs-string">&#x27;cell_type&#x27;</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>对于使用的任何分类变量，使用<em>ModuleTraitCorrelation</em>函数都会打印出一条警告消息，可忽视该警告，警告只是为了确保输入的分类变量有生物学意义。</p><h3 id="检查输出"><a href="#检查输出" class="headerlink" title="检查输出"></a>检查输出</h3><p>mt_cor是一个列表；cor保存相关结果，pval保存相关 p 值，fdr保存 FDR 校正的 p 值。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># get the mt-correlation results</span><br>mt_cor <span class="hljs-operator">&lt;-</span> GetModuleTraitCorrelation<span class="hljs-punctuation">(</span>seurat_obj<span class="hljs-punctuation">)</span><br><br><span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>mt_cor<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="绘制相关热图"><a href="#绘制相关热图" class="headerlink" title="绘制相关热图"></a>绘制相关热图</h3><p>使用<em>PlotModuleTraitCorrelation</em>函数绘制相关性分析的结果。该函数为每个相关性矩阵创建一个单独的热图，然后进行拼图。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs R">PlotModuleTraitCorrelation<span class="hljs-punctuation">(</span><br>  seurat_obj<span class="hljs-punctuation">,</span><br>  label <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;fdr&#x27;</span><span class="hljs-punctuation">,</span><br>  label_symbol <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;stars&#x27;</span><span class="hljs-punctuation">,</span><br>  text_size <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  text_digits <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>  text_color <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;white&#x27;</span><span class="hljs-punctuation">,</span><br>  high_color <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;yellow&#x27;</span><span class="hljs-punctuation">,</span><br>  mid_color <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;black&#x27;</span><span class="hljs-punctuation">,</span><br>  low_color <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;purple&#x27;</span><span class="hljs-punctuation">,</span><br>  plot_max <span class="hljs-operator">=</span> <span class="hljs-number">0.2</span><span class="hljs-punctuation">,</span><br>  combine<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><br><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/WGCNA/ME_Trait_correlation_fdr.png"></p><h1 id="hdWGCNA与WGCNA-R包比较"><a href="#hdWGCNA与WGCNA-R包比较" class="headerlink" title="hdWGCNA与WGCNA R包比较"></a>hdWGCNA与WGCNA R包比较</h1><ol><li>使用WGCNA分析scRNA数据时，需要提取表达量矩阵进行分析。hdWGCNA可直接对接Seurat R包，直接基于Seurat结果进行下游分析：每个clusters随机抽取20%的细胞，可以选择使用全部的基因或者仅使用seurat挑选出来的高变基因，以及不同的降维方式和维度数，用于共表达模块的WGCNA检测，选取软阈值。中间部分与WGCNA无区别。最后，在单细胞空间中计算不同模块的平均表达式，并绘制降维图。生成所有模块的图表示，并可选择进行对应的GO富集分析。</li><li>基于metacells重新进行normalize后的数据进行分析,考虑到单细胞矩阵稀疏的特点，增加了数据的稳健性。</li><li>下游可视化形式更加丰富，除了WGCNA经典的模块与性状相关性热图，模块识别聚类树图等，增加了结合Seurat进行可视化，网络分析，差异模块特征基因（类似差异分析）分析，富集分析（图片有点丑），将生成的模块信息投影到其他数据集（可以将单细胞数据生成的模块信息投影到ATAC-seq,空转或者其他物种的单细胞数据集中）的内容。</li><li>hdWGCNA中的TOM图可视化需要手动实现。</li><li>hdWGCNA主要集中在对模块特征基因的展示，并以umap形式提供模块中全部基因的展示（与WGCNA生成的聚类图箱线图和柱状图相比，在细胞数和基因数较多时可视化方式更友好）。</li></ol><h1 id="hdWGCNA耗时统计"><a href="#hdWGCNA耗时统计" class="headerlink" title="hdWGCNA耗时统计"></a>hdWGCNA耗时统计</h1><p>demo数据 36601基因，36671细胞</p><ul><li>SetUpForWGCN初始化设置耗时：1.690009 mins</li><li>Meta细胞构建: 6.070287 mins</li><li>SetDatExpr运行时间: 0.6600406 secs</li><li>软阈值选择: 50.69805 secs</li><li>构建共表达网络耗时：5.24069 mins</li><li><strong>模块特征基因</strong>： 1.20085 hours</li></ul><h1 id="复习关键名词"><a href="#复习关键名词" class="headerlink" title="复习关键名词"></a>复习关键名词</h1><ul><li>ME：通过对包含每个模块的基因表达矩阵执行(PCA)来计算获得的“伪基因”。每个PCA矩阵的第一个PC是MEs。</li><li>kME: 是根据MEs的连通性的排名，排名越高，就证明这个基因是共表达网络中高度连接的成员，主要用于筛选hub-gene.</li><li>hME: 对MEs使用Harmony对sampleid矫正后获得的值。在基础可视化部分默认用到。</li></ul><p><a href="https://www.jianshu.com/p/37937a27c77e">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于SCENIC的转录因子分析原理讲解与实操</title>
    <link href="/2023/05/22/SCENIC/"/>
    <url>/2023/05/22/SCENIC/</url>
    
    <content type="html"><![CDATA[<p>基于SCENIC的单细胞转录因子分析原理讲解与实操</p><span id="more"></span><h2 id="转录因子的定义"><a href="#转录因子的定义" class="headerlink" title="转录因子的定义"></a>转录因子的定义</h2><p>转录因子, transcription factor(TF), 是调节基因转录的蛋白质，它们通常是由蛋白质，或者短的非编码 RNA 组成。转录因子通常以复合体的形式工作，形成多重相互作用，允许对转录速率进行不同程度的控制。</p><p>它们的功能是调节（打开和关闭）基因，以确保基因在细胞和生物体的整个生命过程中在正确的时间以正确的数量在正确的细胞中表达。TF在整个生命过程中协调指导细胞分裂、细胞生长和细胞死亡；指导胚胎发育过程中的细胞迁移和组织发育；或间歇性地响应来自细胞外的信号，例如激素。人类基因组中有多达 2600 个转录因子。</p><p>真核生物通常在基因上游有一个启动子区域，或者在基因上游或下游有一个增强子区域，具有被各种类型的 TF 识别的某些特定基序(<strong>motif</strong>)。转录因子结合、吸引其他转录因子并形成一个复合物，最终促进 RNA 聚合酶的结合，从而开始转录过程。<br><img src="/2023/05/22/SCENIC/p1.png"></p><p>细胞的转录状态来源于潜在的基因调控网络（GRN），它包括一定数量的转录因子（TFs）和辅因子及其下游靶基因。SCENIC可识别TFs与潜在靶基因的共表达模块（Regulon），进而推断基因调控网络及细胞状态。</p><p><strong>Tips:Regulon是受同一个TF调控的靶基因的集合。</strong></p><h2 id="SCENIC简介"><a href="#SCENIC简介" class="headerlink" title="SCENIC简介"></a>SCENIC简介</h2><p>SCENIC开创性的工作是在R中完成的，结果于<a href="https://www.nature.com/articles/nmeth.4463">2017年发表在nature methods上</a>，后来研究人员对其进行了python的实现，开发了<a href="https://doi.org/10.1038/s41596-020-0336-2">pyscenic</a>。</p><p>pyscenic的一大优点是使用了基于分布式计算的框架，因此对运行速度有了极大的提升，但由于R版本的SCENIC更方便进行与seurat包的对接，产生比较多的中间文件，方便个性化分析和下游的可视化处理。<br>若需使用pyscenic, 可以参考natrue protocal中的论述和<a href="https://pyscenic.readthedocs.io/en/latest/tutorial.html">官方链接</a>进行学习,pyscenic可以使用nextflow或者docker直接进行安装使用，流程也是比较简单。</p><h2 id="SCENIC代码实操"><a href="#SCENIC代码实操" class="headerlink" title="SCENIC代码实操"></a>SCENIC代码实操</h2><h3 id="0-Pre-processing"><a href="#0-Pre-processing" class="headerlink" title="0.Pre-processing"></a>0.Pre-processing</h3><p>由于R版本的SCENIC需要使用GENIE3算法，它基于随机森林，运行时间较长长，因此在demo数据分析时需要对数据集进行降采样的处理，也就是抽出其中的一部分细胞和基因进行分析，以减少内存和cpu消耗(此操作不适合正式分析)</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#由于细胞数过多，所以将我们的demo数据抽取一部分细胞（需根据硬件配置决定是否抽取细胞）</span><br>seurat_ob <span class="hljs-operator">=</span> readRDS<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;demo_ob_2000_add_celltype.rds&quot;</span><span class="hljs-punctuation">)</span><br><br>target_cell<span class="hljs-operator">=</span><span class="hljs-number">200</span><br>sample_ratio<span class="hljs-operator">=</span>target_cell<span class="hljs-operator">/</span><span class="hljs-built_in">dim</span><span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span><br>groupby<span class="hljs-operator">=</span><span class="hljs-string">&quot;celltype&quot;</span><br><span class="hljs-comment">#使用set.seed()用于设定随机数种子，每个独特的随机数种子会生成一个和它匹配的伪随机序列，主要用于在调试程序的时候保证结果的可重复性。</span><br>set.seed<span class="hljs-punctuation">(</span><span class="hljs-number">123</span><span class="hljs-punctuation">)</span><br>sampled_cellmeta <span class="hljs-operator">=</span> seurat_ob<span class="hljs-operator">@</span>meta.data <span class="hljs-operator">%&gt;%</span> rownames_to_column<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span><br>                    group_by<span class="hljs-punctuation">(</span> .dots<span class="hljs-operator">=</span> groupby <span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span><br>                    sample_frac<span class="hljs-punctuation">(</span> size <span class="hljs-operator">=</span> sample_ratio<span class="hljs-punctuation">,</span>replace <span class="hljs-operator">=</span> <span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span> column_to_rownames<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br>seurat_ob<span class="hljs-operator">@</span>meta.data<span class="hljs-operator">$</span>Barcodes <span class="hljs-operator">=</span> rownames<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-operator">@</span>meta.data<span class="hljs-punctuation">)</span><br>seurat_ob <span class="hljs-operator">=</span> seurat_ob<span class="hljs-punctuation">[</span><span class="hljs-punctuation">,</span>seurat_ob<span class="hljs-operator">@</span>meta.data<span class="hljs-operator">$</span>Barcodes <span class="hljs-operator">%in%</span> rownames<span class="hljs-punctuation">(</span>sampled_cellmeta<span class="hljs-punctuation">)</span><span class="hljs-punctuation">]</span><br><br><span class="hljs-comment">#由于基因数过多，所以将我们的demo数据抽取一部分基因（请勿在正式分析中进行）</span><br>genelist <span class="hljs-operator">=</span> read.delim<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;./DATABASE/hs_hgnc_tfs.txt&quot;</span><span class="hljs-punctuation">,</span>header <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">)</span><br>genelist <span class="hljs-operator">=</span> intersect<span class="hljs-punctuation">(</span>genelist<span class="hljs-operator">$</span>V1<span class="hljs-punctuation">,</span>rownames<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>genelist_append <span class="hljs-operator">=</span> sample<span class="hljs-punctuation">(</span>setdiff<span class="hljs-punctuation">(</span>rownames<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> genelist<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><span class="hljs-number">1000</span><span class="hljs-punctuation">)</span><br>genelist <span class="hljs-operator">=</span> append<span class="hljs-punctuation">(</span>genelist<span class="hljs-punctuation">,</span> genelist_append<span class="hljs-punctuation">)</span><br>seurat_ob <span class="hljs-operator">=</span> seurat_ob<span class="hljs-punctuation">[</span>genelist<span class="hljs-punctuation">,</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><h3 id="1-共表达-Co-expression"><a href="#1-共表达-Co-expression" class="headerlink" title="1.共表达(Co-expression)"></a>1.共表达(Co-expression)</h3><p>SCENIC正式工作流程的第一步是根据表达数据推断所有转录因子的潜在靶标。为此，我们使用GENIE3或GRNBoost。</p><p>输入文件是过滤后的表达矩阵（可以是csv格式 ，loom格式或者Seurat对象里的counts矩阵）。</p><p>GENIE3&#x2F;GRNBoost使用了不同的机器学习算法，GENIE3使用了基于决策树的bagging算法，使用了随机森林整合多个决策树。 GRNBoost使用了boosting 。但两者的输出结果是相似的，都是一个矩阵，包括转录因子，靶标基因和权重(Importance)构成的表格，我们将其称之为共表达模块(moudle)。</p><p>图中有N个基因，将会以每个基因作为输出（靶基因表达量），其余基因作为输入（调控基因表达量）来构建N个随机森林模型。进而计算每一个模型中，每个调控基因对靶基因的重要性，从而得出它们之间的调控关系。然后根据所有模型的调控关系进行排序。权重是转录因子对每个基因表达情况的影响的一个程度。<br><img src="/2023/05/22/SCENIC/p2.png"></p><p>为了在SCENIC的多个步骤中保持一致的设定和输出结果文件的命名，SCENIC包中的大多数函数使用<em>scenicOptions</em>作为公共对象，它存储当前运行的选项并使用默认参数代替大多数函数的“参数”，从而保证了一致性。这一步需要在SCENIC运行之初就使用initializeScenic进行设置，需要设置的内容包括org（也就是物种），dbDir（数据库的路径）等。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#对SCENIC进行初始化 </span><br><span class="hljs-comment">#由于feather进行过版本更新，请从如下链接下载数据库</span><br><span class="hljs-comment">#https://resources.aertslab.org/cistarget/databases/old/</span><br>dbs <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;hg38__refseq-r80__500bp_up_and_100bp_down_tss.mc9nr.feather&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;hg38__refseq-r80__10kb_up_and_down_tss.mc9nr.feather&quot;</span><span class="hljs-punctuation">)</span><br><span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>dbs<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;500bp&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;10kb&quot;</span><span class="hljs-punctuation">)</span> <br>scenicOptions <span class="hljs-operator">&lt;-</span> initializeScenic<span class="hljs-punctuation">(</span>org<span class="hljs-operator">=</span><span class="hljs-string">&quot;hgnc&quot;</span><span class="hljs-punctuation">,</span> dbDir<span class="hljs-operator">=</span><span class="hljs-string">&quot;D:/Data/Scenic/DATABASE&quot;</span><span class="hljs-punctuation">,</span>dbs <span class="hljs-operator">=</span> dbs<span class="hljs-punctuation">,</span>nCores <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p>Tips:</p><p>RcisTarget数据库只支持三个物种</p><ul><li>小鼠 mgi</li><li>人类 hgnc</li><li>果蝇 dmel</li></ul><p>dbDir下存放四个文件：</p><ul><li>feather文件：保存<a href="https://resources.aertslab.org/cistarget/databases/">Gene-motif排名</a>数据库，为每个motif提供所有gene的排名，在接下来的motif富集分析中会用到</li><li>hs_hgnc_tfs.txt: 保存<a href="https://github.com/aertslab/pySCENIC/tree/master/resources/">转录因子列表</a>，这个文件在构建共表达矩阵的时候就要用到，因为要告诉SCENIC，你的输入矩阵里哪些基因是转录因子。</li><li>tbl文件：<a href="https://resources.aertslab.org/cistarget/motif2tf/">转录因子的Motif注释文件</a>，该文件对每一个motif注释其所对应的TF，这也是motif富集用到。<br><img src="/2023/05/22/SCENIC/p3.png"></li></ul><p>注意下feather羽毛文件的版本，由于在SCENIC在20220816日更新，现在pyscenic仅支持 Feather v2 格式的数据库 ( ctxcore )，它允许使用最新版本的 pyarrow ( ) 而不是旧版文件。我们在使用R版本的Scenic时，由于arrow包无法读入最新版本的feather格式，因此在下载数据库的时候需要下载<a href="https://resources.aertslab.org/cistarget/databases/old/">旧版文件</a>。</p><p>接下来我们<strong>对基因进行过滤</strong>，目的是去除最可能是噪音的基因。</p><p>主要是根据两个点对基因进行过滤：该基因的count数，和在多少细胞中被检出。具体的阈值是case by case, 我们这里是使用minCountsPerGene保留在所有样品中至少有1个counts的基因。minSamples设置为保证保留下来的基因能在至少1％的细胞中检测得到。使用geneFiltering函数对基因进行过滤。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#对基因进行过滤 </span><br><span class="hljs-comment">#本次的过滤标准是过滤掉基因表达于少于1%的细胞中的基因 </span><br>minCell4gene <span class="hljs-operator">=</span> <span class="hljs-built_in">round</span><span class="hljs-punctuation">(</span><span class="hljs-number">0.01</span> <span class="hljs-operator">*</span> ncol<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <br><span class="hljs-comment">#提取counts矩阵</span><br>exprMat <span class="hljs-operator">=</span> seurat_ob<span class="hljs-operator">@</span>assays<span class="hljs-operator">$</span>RNA<span class="hljs-operator">@</span>counts <br>genesKept <span class="hljs-operator">&lt;-</span> geneFiltering<span class="hljs-punctuation">(</span>as.matrix<span class="hljs-punctuation">(</span>exprMat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <br>scenicOptions<span class="hljs-operator">=</span>scenicOptions<span class="hljs-punctuation">,</span> <br>minCountsPerGene<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> <br>minSamples<span class="hljs-operator">=</span>minCell4gene<span class="hljs-punctuation">)</span> <br><br><span class="hljs-comment">#GRN的输入文件是对基因过滤后的count matrix </span><br>exprMat_filtered <span class="hljs-operator">&lt;-</span> exprMat<span class="hljs-punctuation">[</span>genesKept<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/SCENIC/p4.png"></p><p>可以看到SCENIC生成的中间文件和图文件将会保存到int文件夹中，并且会按顺序整齐排列好。可以使用这些中间文件来检查之前做过的每个步骤，或者是以一些不同的设置重新运行其中的分析。重要的输出结果会保存到output文件夹中。</p><p>这步生成的过滤之后的基因列表就被保存在1.1geneKept.rds中了。使用保留下来的这些基因对矩阵的行进行筛选，最终的这个exprMat_filtered对象所保存的count matrix就是GRN的输入文件。 </p><p>接下来我们<strong>读取转录因子列表文件</strong>（在数据库路径下），使用Seurat包的CaseMatch函数，对转录因子名称进行过滤，仅保留匹配到矩阵中的基因名。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#从初始化时指定的dbDir里，根据指定的物种调取tbl文件里的TFs的名字并去重 </span><br>tf_names <span class="hljs-operator">=</span> getDbTfs<span class="hljs-punctuation">(</span> scenicOptions <span class="hljs-punctuation">)</span> <br><br><span class="hljs-comment">#使用Seurat包的CaseMatch函数，对tf_names进行过滤，仅保留匹配到gene matrix中的基因名 </span><br>tf_names <span class="hljs-operator">=</span> CaseMatch<span class="hljs-punctuation">(</span>search<span class="hljs-operator">=</span>tf_names<span class="hljs-punctuation">,</span> match <span class="hljs-operator">=</span> rownames<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p>现在我们正式开始构建共表达网络。R scenic默认的方式是使用GENIE3进行共表达网络的构建。GENIE3使用的是随机森林的方法，他对样本和特征的选取是随机的，所以每次运行的结果可能会稍有不同。因此，我们可以使用Seed随机数种子来保证结果的一致性。GENIE3的运行速度较慢，适合5千细胞以下的数据集。</p><p>另一种方法是使用grnboost2进行共表达网络的构建。可以从R中切出去直接运行pyscenic，或者如演示代码所示，使用reticulate R包直接调用Arboreto模块来直接执行grnboost2，由于pyscenic需要配置额外的python环境，我们在这里只使用genie3进行演示。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#方法一：直接运行GENIE3 （适合5k以下细胞） </span><br>scenicOptions<span class="hljs-operator">@</span>settings<span class="hljs-operator">$</span>seed <span class="hljs-operator">=</span> <span class="hljs-number">123</span> <br>runGenie3<span class="hljs-punctuation">(</span>as.matrix<span class="hljs-punctuation">(</span>exprMat_filtered<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> scenicOptions<span class="hljs-punctuation">)</span> <br><br><span class="hljs-comment">#方法二：调用Grnboost2</span><br><span class="hljs-comment">#使用reticulate包调用基于python的arboreto模块 </span><br><span class="hljs-comment">#可以添加seed随机数种子，保证结果的可重复性seed=123 </span><br>arb.algo <span class="hljs-operator">=</span> import<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;arboreto.algo&quot;</span><span class="hljs-punctuation">)</span> <br>adjacencies <span class="hljs-operator">=</span> arb.algo<span class="hljs-operator">$</span>grnboost2<span class="hljs-punctuation">(</span>as.data.frame<span class="hljs-punctuation">(</span>t<span class="hljs-punctuation">(</span>as.matrix<span class="hljs-punctuation">(</span>exprMat_filtered<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> tf_names<span class="hljs-operator">=</span>tf_names，<span class="hljs-punctuation">,</span> seed<span class="hljs-operator">=</span><span class="hljs-number">123L</span><span class="hljs-punctuation">)</span> <br><br>colnames<span class="hljs-punctuation">(</span>adjacencies<span class="hljs-punctuation">)</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span> <span class="hljs-string">&quot;TF&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;Target&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;weight&quot;</span> <span class="hljs-punctuation">)</span> <br><span class="hljs-comment">#将生成的adjacencies保存到结果文件中</span><br>saveRDS<span class="hljs-punctuation">(</span> adjacencies<span class="hljs-punctuation">,</span> file <span class="hljs-operator">=</span> getIntName<span class="hljs-punctuation">(</span>scenicOptions<span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;genie3ll&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p>Tips:GENIE3和Grnboost运行结果的差异。<br>注意，grnboost2和Genie3的输出文件的表头不同，可以看到GENIE3的表头是weight，而Grnboost的表头是importance。为了让scenic识别我们用grnboost生成的文件，需要注意修改列名，变为weight。</p><p><img src="/2023/05/22/SCENIC/p5.png"></p><p>若是使用pyscenic进行共表达分析，后面可视化使用R语言，可以注意下这点区别。 Genie3的输出文件里还有一系列的1.3文件，但都不重要，这一步最重要的是1.4的矩阵。</p><p>Tips:查看SCENIC默认的命名规范。左侧提醒我们这个文件里保存了什么信息，右侧是文件名，方便我们查找。<br><img src="/2023/05/22/SCENIC/p6.png"></p><p>上一步生成的adjacencies的共表达的结果中既有正调控也有负调控，需要<strong>相关性矩阵</strong>来协助筛选共表达模块中与转录因子正相关的基因。因此我们使用<em>runcoorelation</em>命令，储存基因基因之间spearman相关性的矩阵。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#使用该命令会生成int/1.2_corrMat.Rds 文件，用于储存基因spearman相关性矩阵 </span><br>runCorrelation<span class="hljs-punctuation">(</span>as.matrix<span class="hljs-punctuation">(</span>exprMat_filtered<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> scenicOptions<span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/SCENIC/p7.png"></p><p>基于这个矩阵，可以使用runSCENIC_1_coExpressNetwork命令推断共表达模块。之前提到过scenicOptions存储了默认的参数，因此可以直接输入scenicOptions以代替coExpressNetwork命令的参数。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#推断共表达模块（module） </span><br>runSCENIC_1_coexNetwork2modules<span class="hljs-punctuation">(</span>scenicOptions<span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/SCENIC/p8.png"></p><p>module(模块)现在已经生成了，并且被保存在1.6_tfModules_asDF.Rds文件中。里面显示了转录因子，靶基因和对IM值，就是权重的过滤标准（毕竟module不能无限大嘛）和corr相关性列，scenic只选取数值为1的数据用于后续分析。</p><p>查询SCENIC代码参数<a href="https://rdrr.io/github/aertslab/SCENIC/man/">网址</a></p><h3 id="2-使用motif验证TF与gene的靶向关系"><a href="#2-使用motif验证TF与gene的靶向关系" class="headerlink" title="2. 使用motif验证TF与gene的靶向关系"></a>2. 使用motif验证TF与gene的靶向关系</h3><p>基于表达量矩阵生成module之后，就需要验证TF与gene的靶向关系。TF是通过直接与DNA序列上基因转录起始位点附近的motif序列结合而发挥作用的，因此我们可以通过查看gene上是否存在TF结合的motif序列来去除转录因子不与其直接作用的靶基因。</p><p>我们以左下角这个图为例来说明，假设我们有转录因子1，它与motif1进行结合，调控基因转录。还有一个转录因子2,它与motif2进行结合。假设对于某个module，我们有五个靶基因，target gene 1-5，我们根据motif的富集情况开始对基因进行排名。</p><p>基于gene-motif数据库，也就是我们输入的feather文件，我们已经获得了每个基因转录起始位点附近的motif富集情况，比如对于TG5来说，它的转录起始位点附近有3个Motif 2，比TG1到4都多，所以我们把它排在第一名。这个module的基因集中，TG4的转录起始位点附近有2个motif，所以把它排在第二名。以此类推，就可以对module里的所有基因进行排名。</p><p>然后我们绘制积累曲线，这个图里的横坐标是该物种全基因组的基因对M2富集情况的排名，我们在全基因组排名前5%的基因里寻找我们这个module里有的基因，每找到一个就在y轴上加1。然后计算积累曲线的曲线下面积，就是AUC值。使用公式：该motif的AUC值减去所有motif中的AUC值再除以AUC的标准差，我们就获得了标准化的富集得分。</p><p>NES大于3，证明该motif在基因集的大部分基因里出现富集，并且基因排名靠前。由此我们可以剔除非转录因子直接调控的基因，最终获得TF和靶基因的(regulons)。</p><p><img src="/2023/05/22/SCENIC/p9.png"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#使用motif验证共表达模块 </span><br>runSCENIC_2_createRegulons<span class="hljs-punctuation">(</span>scenicOptions<span class="hljs-punctuation">,</span> coexMethod <span class="hljs-operator">=</span> <span class="hljs-string">&quot;top10perTarget&quot;</span><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p>这里我们添加了Coexmethod参数，这个参数是以选择用哪个IM阈值生成的module，不同的IM阈值最终会产生不同大小的基因集。如果不加Coexmethod参数，就默认的六种过滤方法生成的module都用，包括基于固定阈值（0.001和0.005）；基于每个转录因子的前50个靶基因产生module；根据每个基因的前5,10，或50个转录因子产生module; </p><p><img src="/2023/05/22/SCENIC/p10.png"></p><p>这一步生成的文件主要就是这个转录因子富集结果的网页展示图。数据库直接注释到的和同源基因推断转录因子为高可信度，使用Motif的序列相似性注释到的转录因子为低可信度结果。</p><p>Tips: Step2_MotifEnrichment_preview.html文件展示<br><img src="/2023/05/22/SCENIC/p11.png"></p><h3 id="3-Regulon活性定量"><a href="#3-Regulon活性定量" class="headerlink" title="3. Regulon活性定量"></a>3. Regulon活性定量</h3><p>上一步我们已经获得regulon了，这一步我们针对以Regulons中所有基因作为基因集，针对每个细胞，将细胞中所有基因按照表达量从高到低进行排序，根据Regulons中的基因在排序中的位置，计算累计曲线面积 (AUC) ，即为Regulons在细胞中的活性。这步输出是以regulon为行，细胞为列的这样一个矩阵。其实这种矩阵对细胞类型清晰的数据集已经够用了。但对于细胞类型不清晰的数据集，SCENIC建议可以将AUC矩阵进行二值化，使用混合高斯模型，根据AUC值的双峰分布特征计算阈值，评估regulon处于on还是off的状态。二值化的AUC矩阵可以最大程度的体现细胞间的差异，可以用于细胞聚类，消除技术偏移，甚至消除跨物种比较的差异。<br><img src="/2023/05/22/SCENIC/p12.png"></p><p>这一步我们首先需要重新运行intilalizeScenic，将并行处理取消，也就是将nCores设置为1。 然后运行<em>runSCENIC 3 scorecells</em>。运行之后将AUC矩阵保存回seurat对象的SCENIC slot中。可以看到这步可以生成以3开头的中间文件，而且SCENIC会使用AUC矩阵自动进行tsne的降维聚类，结果输出在output文件夹中的step3系列文件。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#使用AUC对每个细胞的regulon进行打分 </span><br>dbs <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;hg38__refseq-r80__500bp_up_and_100bp_down_tss.mc9nr.feather&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;hg38__refseq-r80__10kb_up_and_down_tss.mc9nr.feather&quot;</span><span class="hljs-punctuation">)</span><br>scenicOptions <span class="hljs-operator">&lt;-</span> initializeScenic<span class="hljs-punctuation">(</span>org<span class="hljs-operator">=</span><span class="hljs-string">&quot;hgnc&quot;</span><span class="hljs-punctuation">,</span> dbDir<span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Data/Scenic/DATABASE&quot;</span><span class="hljs-punctuation">,</span> nCores<span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span>dbs <span class="hljs-operator">=</span> dbs<span class="hljs-punctuation">)</span><br>runSCENIC_3_scoreCells<span class="hljs-punctuation">(</span>scenicOptions<span class="hljs-punctuation">,</span>log2<span class="hljs-punctuation">(</span>as.matrix<span class="hljs-punctuation">(</span>exprMat_filtered<span class="hljs-punctuation">)</span><span class="hljs-operator">+</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/SCENIC/p13.png"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#将AUC矩阵保存回seurat对象中 </span><br>regulonAUC <span class="hljs-operator">&lt;-</span> loadInt<span class="hljs-punctuation">(</span>scenicOptions<span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;aucell_regulonAUC&quot;</span><span class="hljs-punctuation">)</span><br>regulonAUC_mat <span class="hljs-operator">=</span> AUCell<span class="hljs-operator">::</span>getAUC<span class="hljs-punctuation">(</span>regulonAUC<span class="hljs-punctuation">)</span><br>seurat_ob<span class="hljs-punctuation">[[</span><span class="hljs-string">&quot;SCENIC&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> CreateAssayObject<span class="hljs-punctuation">(</span>counts <span class="hljs-operator">=</span> regulonAUC_mat<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/SCENIC/p14.png"></p><p>如果需要对AUC进行二值化，可以使用runSCENIC_4_aucell_binarize。使用该函数会在int文件夹下生成以4开头的rds文件及output文件夹下的Step4系列文件 。可以看到这次生成的文件就是二值化的AUC矩阵。 如果AUC值小于计算得来的阈值，则判定为该Regulons在该细胞中未开放，即未发挥调控作用。最终获得每个Regulons在每个细胞中的开放性热图。这里我们不进行展示了。</p><p>Tips: regulon有两种写法，第一种是TF名称+extended+靶基因数目，即转录因子与所有靶基因组成的基因调控网络。第二种是TF名称+靶基因数目：转录因子与高可信度靶基因组成的表达网络。</p><h2 id="结果可视化"><a href="#结果可视化" class="headerlink" title="结果可视化"></a>结果可视化</h2><h3 id="结合Seurat对SCENIC的结果进行图片展示"><a href="#结合Seurat对SCENIC的结果进行图片展示" class="headerlink" title="结合Seurat对SCENIC的结果进行图片展示"></a>结合Seurat对SCENIC的结果进行图片展示</h3><p>可视化的方式比较多，但使用到的都是生成的3.4 regulonAUC.rds的矩阵。</p><ol><li>按照celltype分组绘制regulon平均活性的热图。<br>先把seurat对象的Idents改成meta.data里想要的分组变量列，我们这里是celltype。然后将分组信息以数据框dataframe的格式保存到CellInfo中。使用LoadInt加载AUC矩阵，使用onlyNonDuplicatedExtended对regulon进行过滤。然后我们对AUC矩阵分组计算平均AUC值，使用scale函数进行归一化，然后使用complexheatmap进行热图的绘制。</li></ol><p>Tips:<br>onlyNonDuplicatedExtended的作用：如果同时存在高置信度的regulon和转录因子与所有靶基因组成的regulon,就仅保留高置信度的regulon。</p><ol start="2"><li><p>降维图<br>可以使用Seurat的降维结果对感兴趣的regulon进行展示 ，展现一个映射AUC值的umap降维图。读入AUC矩阵，使用readRDS直接读入的矩阵是aucell包自带的文件格式，需要使用AUCell::getAUC进行转化。最后，将AUC矩阵加回seurat对象的metadata中，将我们感兴趣的调控因子映射到Umap降维图中。</p></li><li><p>小提琴和山脊图。<br>流程和之前类似，都是读入AUC矩阵，使用AddMetaData函数将AUC矩阵加回到seurat的metadata中。分别使用Ridgeplot和vlnplot绘制山脊图和小提琴图。<br><img src="/2023/05/22/SCENIC/p15.png"></p></li></ol><h3 id="Regulon-specific-score-RSS"><a href="#Regulon-specific-score-RSS" class="headerlink" title="Regulon specific score(RSS)"></a>Regulon specific score(RSS)</h3><p><strong>Regulon specific score(RSS)预测了regulon与每种细胞类型的特定对应关系，RSS值越高表示该regulon在对应的细胞类型中特异性越⾼</strong>。<br><img src="/2023/05/22/SCENIC/p16.png"><br>RSS需要两个vector进行计算，PR反应的是RAS在所有细胞中的分布。针对单个细胞，RAS就是选定regulon对应的AUC值，⽽针对每个细胞群，根据细胞的RAS，剔除细胞群中<br>活性得分超出中位值±3倍mad值的（异常值）细胞后，以平均值代表该细胞类型的RAS。对PR进行标准化。</p><p>然后用另一个vector PC来判断一个细胞是否属于一个特定的细胞类型，若属于则赋值为1，反之赋值为0。 这就是代表一种极端理想的情况，就是选择的regulon仅在这一个细胞类型中具有活性，也就是说是这种细胞类型独有的regulon。对pc同样进行标准化。</p><p>然后计算JSD值来评估两个vector之间的差异。JSD的值在0到1之间，0表示两个vector代表的分布完全相同，1表示两个分布完全不同。RSS的计算公式如下。RSS值越大，JSD值越小，计算的regulon在选定的细胞类型中特异性越高。</p><p><img src="/2023/05/22/SCENIC/p17.png"><br>颜色深浅代表zscore值，点的大小代表rss评分。绘制只需根据seurat对象中的细胞类型信息，计算一下RSS值，然后使用PlotRSS函数就可以进行绘制了。由于我们采用的这个稳定版本的scenic没有内置aux_rss.R的函数（这个函数是封装在Pre-release，也就是内测版的scenic 1.3.0中），所以是使用source的方式进行R脚本的调用的。</p><p>下图为RSS_ranking_plot，横坐标表示排名，纵坐标表示RSS得分。RSS越高的调控子可能与该细胞群特异性相关。<br><img src="/2023/05/22/SCENIC/p18.png"><br>针对感兴趣的细胞类型查看细胞特异性Regulon。前面的绘图准备工作都和plotRSS是一致的，只不过这一步使用到的函数是plotRSS_onSet（可以从scenic的github查看，我们这里是直接把函数拆分了进行画图），输入rds，设置想要看到多少个细胞特异性regulon，我们这里是设置成了五个，然后使用setName设置感兴趣的细胞类型，绘图即可。</p><h3 id="Connection-Specificity-Index（CSI）"><a href="#Connection-Specificity-Index（CSI）" class="headerlink" title="Connection Specificity Index（CSI）"></a>Connection Specificity Index（CSI）</h3><p>第二个在scenic分析中常用的指标是CSI， <strong>该指标用来划分regulon module，展示不同Regulon之间的关联性，同时具有较高CSI的Regulon可能共同调控下游基因，并共同负责细胞功能。</strong></p><p>CSI 的评估包括两个步骤，⾸先计算regulon配对的pearson correlation coefficient（PCC），接下来对于选定的⼀对regulon pair，假设A和B，得到A与B的PCC值，针对其他与A或B相关的配对，统计其中PCC值低于A与B之间PCC值的⽐例，这⼀⽐例就是A与B配对的CSI值，CSI值越⼤表示regulon 配对中的两个regulon相关性越⾼。最后，对所有regulon配对的CSI矩阵进⾏层次聚类（Hierarchical clustering），划分regulon module，对于每⼀个regulon module，其在每种细胞类型中的活性得分等于该细胞类型内所有细胞类型对于该module内所有regulon的RAS的平均值。</p><p>各细胞群中CSI关联模块的活性热图。行表示根据CSI聚类热图进行手动划分的CSI模块，列表示不同细胞群。颜色由蓝变黄表示CSI模块活性由低到高。活性相似的CSI模块对应的细胞群可能具有相似的基因表达模式以及相似的调控网络。<br><img src="/2023/05/22/SCENIC/p19.png"><br>美化后的CSI关联模块的活性热图如下(请结合美化后的Regulon模块的CSI关联性聚类热图共同查看):<br><img src="/2023/05/22/SCENIC/CSI.png"></p><p>下图为Regulon模块的CSI关联性聚类热图，行列均表示regulon，颜色由蓝变黄表示CSI关联性值由低到高。CSI值都较高的regulon可能具有相似的细胞功能，共同调控下游基因。<br><img src="/2023/05/22/SCENIC/p20.png"><br>美化后的Regulon模块的CSI关联性聚类热图如下图，<br><img src="/2023/05/22/SCENIC/p21.png"></p>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cellchat</title>
    <link href="/2023/05/22/Cellchat/"/>
    <url>/2023/05/22/Cellchat/</url>
    
    <content type="html"><![CDATA[<p>Cellchat的学习笔记及代码分享</p><span id="more"></span><h2 id="细胞通讯背景介绍"><a href="#细胞通讯背景介绍" class="headerlink" title="细胞通讯背景介绍"></a><a href="https://doi.org/10.1038/s41576-020-00292-x">细胞通讯背景介绍</a></h2><p>细胞通讯主要由一个信号产生的细胞发出的信息，一般是通过一个介质，也就是配体，传递给靶细胞（如图Y就是受体）。配体和受体之间是特异性结合，靶细胞接触配体后就会产生一系列的生理生化效应。</p><ol><li><p>自分泌(Autocrine)<br>是指同一个细胞内的通讯，细胞通过分泌配体来诱导自身细胞反应。</p></li><li><p>旁分泌(Paracrine)<br>不需要细胞-细胞接触，而是依赖于分泌后信号分子从一个细胞扩散到另一个细胞。</p></li><li><p>近分泌(Juxtacrine)<br>细胞间通讯依靠缝隙连接或其他结构如膜纳米管直接在细胞间传递信号分子，需要细胞相互接触。信号分子不分泌到细胞外空间。</p></li><li><p>内分泌(Endocrine)<br>信号分子通过细胞外液(如血浆)被分泌并长距离传播；这种交流的典型介质是激素。</p></li></ol><p>细胞通讯参与许多生物进程，理解细胞通讯可以帮助我们了解细胞与细胞之间的互作关系。通过选择不同时间点的样本或同类细胞的不同亚群可以揭示发育过程中各类细胞的相互作用。细胞通讯可以用于探索肿瘤免疫微环境，比如先从细胞亚群入手，通过对不同亚群进行受体-配体分析，挑选相互作用最强的亚群，然后探索该亚群与其他细胞类型的相互作用，揭示细胞亚群在肿瘤免疫微环境中的作用机制。也可以用于挖掘疾病治疗靶点等。</p><p><img src="/2023/05/22/Cellchat/cellchat1.png"></p><h2 id="Cellchat"><a href="#Cellchat" class="headerlink" title="Cellchat"></a><a href="https://www.nature.com/articles/s41467-021-21246-9">Cellchat</a></h2><h3 id="Cellchat简介"><a href="#Cellchat简介" class="headerlink" title="Cellchat简介"></a>Cellchat简介</h3><p><a href="http://www.cellchat.org/index_inner.html">Cellchat官网</a></p><p><a href="https://github.com/sqjin/CellChat">Cellchat github</a></p><p>单细胞领域，2021年美国加州大学开发出了cellchat软件用于分析细胞通讯分析。cellchat这个工具具有非常强大的灵活性，不仅可以对细胞通讯网络进行推断和分析，还具有丰富的可视化功能。</p><ul><li>使用单细胞表达谱与已知的细胞通讯数据库进行细胞通讯互作强度的计算。</li><li>通过配体-受体的互作概率与扰动检验，识别显著互作的配体-受体关系对。</li><li>通过加和细胞类型间显著互作的配体-受体关系对数量或者强度来计算和整合细胞间通讯网络。</li></ul><p>虽然同样是从scRNA-seq数据中推断细胞间通讯，但Cellchat与NicheNet等只使用一个配体&#x2F;受体基因对的软件不同，Cellchat将配体-受体+多聚体+辅助因子同时发挥作用的情况纳入考量。这就考虑到了比如细胞因子TGF β在TGFBR2&#x2F;TGFBR1二聚体的参与下调节细胞增殖这种常见的情况。<br><img src="/2023/05/22/Cellchat/cellchat2.png"></p><p>Cellchat强大之处在于它的数据库, CellChat 软件构建了一个配体、受体及其辅因子间相互作用的数据库——<strong>CellChatDB</strong>，cellchat数据库是人工注释的数据库，支持<strong>人和小鼠</strong>受配体互作推断，在其github里发现开发团队更新了斑马鱼的数据库，用户也可以根据自己获得或自己挑选的数据，用cellchat自带的功能对它的数据库更新并使用。这个代码可以帮助用户看的它的数据库组成，我们在后面进行分析时，可以根据需求筛选特定的数据库进行分析。根据通讯方式不同，可以将信号通路分为以下三种：Secreted signaling主要指的就是内分泌，自分泌和旁分泌；Cell-cell Contact主要对应近分泌；ECM受体主要是整合素等其他细胞表面相关成分，通过细胞与细胞外基质接触来介导细胞通讯（是一种特殊的近分泌）。</p><p>提供了<a href="http://www.cellchat.org/cellchatdb/">Web端</a>可用于搜索受配体</p><p><img src="/2023/05/22/Cellchat/cellchat3.png"></p><pre><code class="hljs">#以human为例查看数据库构成showDatabaseCategory(CellChatDB.human) </code></pre><p><img src="/2023/05/22/Cellchat/cellchat4.png"></p><h3 id="Cellchat-分析原理"><a href="#Cellchat-分析原理" class="headerlink" title="Cellchat 分析原理"></a>Cellchat 分析原理</h3><p>我们要看细胞亚群之间的通讯作用，首先仍然是需要进行差异分析，计算哪些基因是在细胞群之间存在差异表达，这是通过<em>identifyOverExpressedGenes</em>函数实现的。cellchat使用Wilcoxon检验，在显著性水平为0.05的情况下，在所有细胞组中识别差异表达的信号基因。然后这些过表达基因所在的互作即过表达互作。通过<em>identifyOverExpressedInteractions</em>函数可以识别这些过表达互作，并将他们存于cellchat@LR$LRsig。</p><p>第二步是对不同的细胞群计算一个平均表达水平（使用了基因表达分位数的方式，排除了异常值的影响，公式见文献）</p><p>第三步也是最重要的一步，就是对每个配体受体对计算通信概率。</p><p><strong>配受体对表达情况计算：</strong></p><p>Li代表配体L在细胞群i中的表达水平。如果配体L有多个亚基，计算的是几何平均数作为整体的表达水平：也就是任何一个亚基的零表达都会导致一个无活性的配体。</p><p>Rj代表受体R在细胞群j中的表达水平。如果有多个亚基，仍然计算几何平均数。比较特殊的是，由于共刺激和共抑制膜结合受体能够通过控制受体激活来调节信号，因此在计算受体时，会将共刺激受体纳入考量。<br>对于具有多个共刺激受体的配体-受体对，我们计算了这些共刺激受体的平均表达量(用RA表示)，然后使用线性函数来建模对受体表达的正向调节(activating)。(1+RA)</p><p>对于每个具有多个共抑制受体(RI)的配体-受体对，我们使用相同的线性函数方法对它们进行建模。(1+RI)</p><p><img src="/2023/05/22/Cellchat/cellchat5.png"></p><p><strong>通讯概率计算：</strong></p><p><font color=red>红色框中的部分即为使用Hill系数对<strong>受配体之间的相互作用</strong>进行建模，参数Kh的默认值设为0.5，因为输入数据的归一化范围从0到1。（<a href="https://qinqianshan.com/biology/protein/hill-coe/">希尔系数</a>主要是用于研究蛋白质内部，如果是由多亚基组成，那么这一群亚基之间有怎样的作用关系，这里是取它的延伸作用。 Kh在希尔方程中常作为解离常数，来源于质量作用定律）</font></p><p><strong>来自发送细胞和接收细胞的胞外激动剂和拮抗剂能够直接或间接地调节配体-受体相互作用:</strong></p><p><font color=Orange>黄色框展示了对<strong>激动剂</strong>的建模。<br>对于含有多个激动剂的配体-受体对，我们计算了这些激动剂(agonist)的平均表达量(用AG表示)，然后使用Hill函数来模拟激动剂对配体-受体相互作用的正调节。</font></p><p><font color=#008000>原理相似，绿色框中的部分为对<strong>拮抗剂</strong>的建模(antagonist)。</font></p><p><font color=Blue>蓝色框这部分会将每个细胞群中<strong>细胞比例的影响</strong>也被纳入概率计算中，其中ni和nj分别为细胞群i和j中的细胞数量，n为给定数据集中的细胞总数。</font></p><p>这样我们就可以计算出来所有配体-受体对之间的所有细胞组之间的通信概率， 这个整体的通讯概率由一个三维array ( K × K × N)表示，其中K是cell group的数量，N是配体-受体对或信号通路的数量。</p><p>我们比较关心在统计学上，这些通讯是否具有显著性呢？</p><p>cellchat会基于置换检验的方法，将细胞标签打乱重排一百次， 生成零分布，计算p值。</p><p>最后通过层次图(hierarchy plot),圈图(Circle plot),气泡图(bubble plot)等多种方式进行结果展示。</p><h2 id="CellphoneDB"><a href="#CellphoneDB" class="headerlink" title="CellphoneDB"></a><a href="https://doi.org/10.1038/s41596-020-0292-x">CellphoneDB</a></h2><h3 id="CellphoneDB-简介"><a href="#CellphoneDB-简介" class="headerlink" title="CellphoneDB 简介"></a>CellphoneDB 简介</h3><p><a href="https://github.com/ventolab/CellphoneDB">CellphoneDB github</a></p><p>CellPhoneDB 构建了一个公开的物种为<strong>人类</strong>的经过人工注释的受体、配体及其相互作用的数据，并配有相应的R包和python包来对单细胞转录组学数据进行分析。</p><p>与cellchat相似，cellphoneDB考虑到了异聚复合物。在存在多个亚基时，表达量是按照最低的亚基进行计算，也就是说cellchat和cellphoneDB都会因为多聚体的任何一个亚基表达量为0而导致多聚体的表达量按0进行计算。cellphoneDB的相互作用注释也比较全面，有两千多种相互作用，同时也支持自定义受配体相互作用。 </p><p>与CellPhoneDB v3相比，CellPhoneDB v4.1版本的可信度更强，因为它不再从外部资源导入交互，而是增加了更多的人工注释条目，并考虑了非蛋白分子作为配体的情况。由于开始支持python，运行速度也得到了大幅提升。</p><h3 id="CellphoneDB原理"><a href="#CellphoneDB原理" class="headerlink" title="CellphoneDB原理"></a>CellphoneDB原理</h3><p>CellphoneDB要求输入normalized后的矩阵(data矩阵)，在给定表达矩阵和细胞注释之后，对于细胞群中的每个基因，在数据集中的所有原细胞分群之间执行成对比较，计算表达该基因的细胞百分比和基因表达的实际平均值。</p><p>然后，随机排列所有细胞的细胞类型标记，形成新的细胞群（默认随机排列1000次），计算随机排列后细胞群中配体的平均表达水平和与其相互作用的细胞类型中受体的平均表达水平的平均值。通过这种方式，在两种细胞类型之间的每对配对比较中为每个配体-受体对生成一个零分布(null distribution)。</p><p>生成零分布之后，根据计算平均值等于或高于实际平均值的比例推测该受体-配体对在这两种细胞类型中可能的显著性P值。</p><p>之后，根据两种细胞类型中富集到的显著的配体-受体对的数量，对细胞群中显著的受配体进行排序，找到特异性的配受体，以便手动筛选出生物学相关的相互作用关系。这样，通过特异性的蛋白复合物，预测了细胞群之间可能的分子相互作用，产生了细胞群间潜在的通讯网络，这些网络可以通过直观的表格和图表进行可视化。</p><p>CellphoneDB的下游可视化相比cellchat要少，可以将生成的表格导入Cytoscape进行网络图的可视化。</p><p><img src="/2023/05/22/Cellchat/cellphoneDB_overview.png"></p><h3 id="CellphoneDB与Cellchat比较"><a href="#CellphoneDB与Cellchat比较" class="headerlink" title="CellphoneDB与Cellchat比较"></a>CellphoneDB与Cellchat比较</h3><p>CellphoneDB:</p><ol><li>基于 人 开发，可通过同源转换应用于小鼠</li><li>考虑二聚体</li><li>CellphoneDB数据库包含将近3000种相互作用。</li><li>考虑200多种涉及带注释的非肽分子（即不由基因编码），例如类固醇激素，的相互作用。</li><li>CellphoneDB v3支持空间信息</li><li>只有表达受体和配体基因的细胞占比超过指定的阈值时（默认为10%），该配体-受体对才会被纳入分析。</li><li>基于Shuffle，运行速度相对较慢（v4.1基于python, 运行速度提升）</li></ol><p>Cellchat:</p><ol><li>基于 人 和 小鼠 开发</li><li>考虑二聚体和<strong>拮抗剂等</strong></li><li>数据库中含有2021种已验证的相互作用，其中60%为分泌信号，48%的相互作用需要二聚体复合体参与。</li><li>Cellchat v1.6.0支持空间信息</li><li>基于R开发</li><li>可以通过结合网络分析、模式识别和流形学习方法，使用集成方法定量表征和比较推断的细胞间通信网络。</li></ol><h2 id="Cellchat-代码详解"><a href="#Cellchat-代码详解" class="headerlink" title="Cellchat 代码详解"></a>Cellchat 代码详解</h2><h3 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h3><p>首先要准备分析数据，也就是构建cellchat对象。我们需要表达矩阵和对应的标识信息两种数据，我们用常见的seurat对象为例，这里用的是我们自己的示例数据，只用于展示分析步骤和产生的结果。</p><p>在读取seurat对象之后，建议将我们需要用于推断互作关系的细胞类群对应的标签设置为seurat对象的ident方便后续转换。cellchat提供了不同的转换方式：</p><p>方案一：我们可以从seurat对象中提取表达矩阵以及细胞对应的meta信息。之后通过createCellchat这个函数手动构建cellchat对象，运行了createCellchat函数之后终端会提示我们从数据矩阵构建的cellchat对象，并且提示我们采用的是哪些细胞类型进行细胞通讯分析。</p><p>方案二：createCellchat这个函数也支持直接将seurat对象转换为cellchat对象。运行之后也可以看到终端提示我们构建数据的来源和即将进行分析的细胞类型。同时我们可以看到，我们之前给seurat对象设置的ident也被添加到cellchat对象的meta信息里了。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs R">seurat_ob <span class="hljs-operator">&lt;-</span> readRDS<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;seurat_ob.rds&quot;</span><span class="hljs-punctuation">)</span><br>seurat_ob <span class="hljs-operator">&lt;-</span> SetIdent<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">,</span> value <span class="hljs-operator">=</span> <span class="hljs-string">&quot;celltype&quot;</span><span class="hljs-punctuation">)</span><br>levels<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#推荐：直接用seurat对象构建cellchat对象</span><br>cellchat <span class="hljs-operator">&lt;-</span> createCellChat<span class="hljs-punctuation">(</span>object <span class="hljs-operator">=</span> seurat_ob<span class="hljs-punctuation">,</span> group.by <span class="hljs-operator">=</span> <span class="hljs-string">&quot;celltype&quot;</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#Optional: 提取cellchat对象所需数据并构建cellchat对象（需要使用normalized data matrix）</span><br>data.input <span class="hljs-operator">&lt;-</span> GetAssayData<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">,</span> assay <span class="hljs-operator">=</span> <span class="hljs-string">&quot;RNA&quot;</span><span class="hljs-punctuation">,</span> slot <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data&quot;</span><span class="hljs-punctuation">)</span>  <br>labels <span class="hljs-operator">&lt;-</span> Idents<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><br>meta <span class="hljs-operator">&lt;-</span> data.frame<span class="hljs-punctuation">(</span>celltype <span class="hljs-operator">=</span> labels<span class="hljs-punctuation">,</span> row.names <span class="hljs-operator">=</span> <span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>labels<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <br><span class="hljs-comment"># 构建cellchat对象 </span><br>cellchat <span class="hljs-operator">&lt;-</span> createCellChat<span class="hljs-punctuation">(</span>object <span class="hljs-operator">=</span> data.input<span class="hljs-punctuation">,</span> meta <span class="hljs-operator">=</span> meta<span class="hljs-punctuation">,</span> group.by <span class="hljs-operator">=</span> <span class="hljs-string">&quot;celltype&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/code1.png"></p><h3 id="设置数据库"><a href="#设置数据库" class="headerlink" title="设置数据库"></a>设置数据库</h3><p>进行细胞通讯分析需要先将数据库添加到cellchat对象中，根据我们样本物种选择对应的数据库，可以使用全部的数据进行计算，也可以根据需要筛选部分数据，将数据添加到cellchat对象的DB slot里。由于是demo数据演示，故只选取了动植物细胞中最常见的通讯方式，也就是分泌信号的数据库，在实操的时候可以改为完整的数据库，看看还有哪些信号通路被纳入分析。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">##设置配体-受体相互作用数据库</span><br>CellChatDB <span class="hljs-operator">&lt;-</span> CellChatDB.human <br><span class="hljs-comment"># use CellChatDB for cell-cell communication analysis</span><br>CellChatDB.use <span class="hljs-operator">&lt;-</span> CellChatDB<br><span class="hljs-comment"># use a subset of CellChatDB for cell-cell communication analysis</span><br>CellChatDB.use <span class="hljs-operator">&lt;-</span> subsetDB<span class="hljs-punctuation">(</span>CellChatDB<span class="hljs-punctuation">,</span> search <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Secreted Signaling&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># 分泌信号</span><br><br><span class="hljs-comment">#将database添加到cellchat对象中</span><br>cellchat<span class="hljs-operator">@</span>DB <span class="hljs-operator">&lt;-</span> CellChatDB.use<br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/code2.png"></p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>官方提示不管是不是需要提取cellchat子集都需要跑subsetdata这一步，其实这一步也是在对我们的数据本身的基因与数据库中的基因取交集并且将对应基因的表达矩阵保存到名为data.signaling 的slot里面，所以需要跑这一步来节约计算成本是必要的。在识别过表达基因（也就是差异分析）和过表达的受配体对之后，（鉴定与每个细胞组相关的过表达信号传导基因（var.features slot）、识别所用cellChatDB中过度表达的配体受体相互作用（对）（LR slot））。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#### 提取表达数据子集 cellchat@data.signaling </span><br><span class="hljs-comment">#即使使用全部的数据集，此步骤也是必须的。</span><br><span class="hljs-comment">#此步骤提取在subsetDB步骤中选取的关注的interaction database中的基因。</span><br><span class="hljs-comment">#此步骤过后，cellchat@data.signaling中提取到了基因的表达矩阵（data矩阵）。</span><br>cellchat <span class="hljs-operator">&lt;-</span> CellChat<span class="hljs-operator">::</span>subsetData<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span> <br><br><span class="hljs-comment">#识别过表达基因，储存在cellchat@var.features</span><br>cellchat <span class="hljs-operator">&lt;-</span> identifyOverExpressedGenes<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#### 识别过表达的受配体对，储存在cellchat@LR</span><br>cellchat <span class="hljs-operator">&lt;-</span> identifyOverExpressedInteractions<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h3 id="细胞通讯概率计算"><a href="#细胞通讯概率计算" class="headerlink" title="细胞通讯概率计算"></a>细胞通讯概率计算</h3><ol><li><p>首先使用<em>computeCommunProb</em>函数计算任何相互作用的<strong>细胞群之间的通信概率&#x2F;强度</strong>，保存在<strong>net slot</strong>里面，里面包括细胞类型对和受体配体对相互作用的信息。此步骤运行稍微耗时。</p></li><li><p>在数据量较大的情况下，细胞两两配对的信息非常多，这里就需要一个筛选的过程，针对某个细胞群内细胞数目小于一定阈值，我们将与它相关的通讯过滤掉。这里使用<em>filterCommunication</em>函数并将阈值设定为10个细胞。</p></li><li><p>computeCommunProbPathway函数通过汇总所有相关配体&#x2F;受体来计算信号<strong>通路水平的通信概率</strong>，并保存在<strong>netP slot</strong>中。</p></li><li><p>最后使用aggregateNet函数通过计算通讯数量或汇总通信概率（强度）来计算聚合网络。还可以通过设置源来计算单元组子集之间的聚合网络。使用souce.use和targets.use。</p></li></ol><p>所有配体-受体对之间的所有细胞组之间的通信概率由一个三维阵列P ( K × K × N)表示，其中K是cell group的数量，N是配体-受体对或信号通路的数量，这个array就是cellchat@net$prob。net由配体&#x2F;受体级别的所有推断细胞通信组成,而netP可以在信号通路级别访问推断的通信</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#### 基于受配体对计算通讯概率，并基于permutation test计算P值，推导通讯网络，将结果储存在 cellchat@net</span><br>cellchat <span class="hljs-operator">&lt;-</span> computeCommunProb<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br><span class="hljs-comment">#注意population.size = FALSE默认参数</span><br><br><span class="hljs-comment">#过滤掉细胞群内细胞数过少的细胞群之间的通讯</span><br>cellchat <span class="hljs-operator">&lt;-</span> filterCommunication<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> min.cells <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#基于信号通路水平推断细胞之间的通讯储存在cellchat@netP</span><br>cellchat <span class="hljs-operator">&lt;-</span> computeCommunProbPathway<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#可以通过函数提取全部通讯网络作为dataframe格式</span><br>df.net <span class="hljs-operator">&lt;-</span> subsetCommunication<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span>slot.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;netP&quot;</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment">#指定信号通路</span><br>df.net <span class="hljs-operator">&lt;-</span> subsetCommunication<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;MIF&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment">#查找指定受配体</span><br>df.net <span class="hljs-operator">&lt;-</span> subsetCommunication<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> sources.use <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;B_cell&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Monocyte&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> targets.use <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;CMP&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#计算聚合的细胞通讯网络，即统计细胞与细胞之间通讯的数量（受配体对数量）和强度（概率）</span><br>cellchat <span class="hljs-operator">&lt;-</span> aggregateNet<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><h2 id="Cellchat可视化"><a href="#Cellchat可视化" class="headerlink" title="Cellchat可视化"></a>Cellchat可视化</h2><h3 id="总体展示"><a href="#总体展示" class="headerlink" title="总体展示"></a>总体展示</h3><p>cellchat自带多种可视化的函数，整体来看各细胞类型直接的互作数量和强度，可以用网络图表示。</p><ul><li>Circle plot<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#使用circle plot显示任意两个细胞group之间的相互作用次数或总交互强度（比重）</span><br>groupSize <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">as.numeric</span><span class="hljs-punctuation">(</span>table<span class="hljs-punctuation">(</span>cellchat<span class="hljs-operator">@</span>idents<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>par<span class="hljs-punctuation">(</span>mfrow <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> xpd<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><br><br>netVisual_circle<span class="hljs-punctuation">(</span>cellchat<span class="hljs-operator">@</span>net<span class="hljs-operator">$</span>count<span class="hljs-punctuation">,</span> vertex.weight <span class="hljs-operator">=</span> groupSize<span class="hljs-punctuation">,</span> weight.scale <span class="hljs-operator">=</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">,</span><br>                 label.edge<span class="hljs-operator">=</span> <span class="hljs-built_in">F</span><span class="hljs-punctuation">,</span> title.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Number of interactions&quot;</span><span class="hljs-punctuation">)</span><br>netVisual_circle<span class="hljs-punctuation">(</span>cellchat<span class="hljs-operator">@</span>net<span class="hljs-operator">$</span>weight<span class="hljs-punctuation">,</span> vertex.weight <span class="hljs-operator">=</span> groupSize<span class="hljs-punctuation">,</span> weight.scale <span class="hljs-operator">=</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">,</span> <br>                 label.edge<span class="hljs-operator">=</span> <span class="hljs-built_in">F</span><span class="hljs-punctuation">,</span> title.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Interaction weights/strength&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><img src="/2023/05/22/Cellchat/p1.png"></li></ul><p>par()函数，是R基础绘图系统中一个比较常见的函数，在CellChat中主要是为了排列多个图形，例如这里的mfrow参数的形式就为c(nr, nc)，表示将后续绘制的图形按照nr行nc列排布，而mfrow表示先横向后纵向，对应的也有mfcol表示先纵向后横向。xpd &#x3D; True是设置允许在作图区域外作图，防止文字显示不全。使用netVisual_circle函数绘制的图展现在右侧，上图左侧展示了通讯的数量，右侧展示了通讯的强度，也就是概率值相加的结果。</p><p>可以看到我们设置了groupSize这个对象，反映了idents，也就是我们的分组变量，celltype的数量。因此，图上的圆圈大小就反应每个细胞类型里的细胞数的多少，线条的粗细反应了通讯的数量或者强度。</p><p>Tips: 单独展示</p><p>分别展示每个细胞类型与其他细胞类群的互作，采用的方式是将不包含该细胞类型的互作数量或者强度设置为0，在图片上就不会显示出来了。可以看”单独展示”这部分的代码。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#单独展示</span><br>mat <span class="hljs-operator">&lt;-</span> cellchat<span class="hljs-operator">@</span>net<span class="hljs-operator">$</span>weight<br>par<span class="hljs-punctuation">(</span>mfrow <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">5</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> xpd<span class="hljs-operator">=</span><span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><br><span class="hljs-keyword">for</span> <span class="hljs-punctuation">(</span>i <span class="hljs-keyword">in</span> <span class="hljs-number">1</span><span class="hljs-operator">:</span>nrow<span class="hljs-punctuation">(</span>mat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-punctuation">&#123;</span><br>mat2 <span class="hljs-operator">&lt;-</span> matrix<span class="hljs-punctuation">(</span><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> nrow <span class="hljs-operator">=</span> nrow<span class="hljs-punctuation">(</span>mat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> ncol <span class="hljs-operator">=</span> ncol<span class="hljs-punctuation">(</span>mat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> <span class="hljs-built_in">dimnames</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">dimnames</span><span class="hljs-punctuation">(</span>mat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>mat2<span class="hljs-punctuation">[</span>i<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;-</span> mat<span class="hljs-punctuation">[</span>i<span class="hljs-punctuation">,</span> <span class="hljs-punctuation">]</span><br>netVisual_circle<span class="hljs-punctuation">(</span>mat2<span class="hljs-punctuation">,</span> vertex.weight <span class="hljs-operator">=</span> groupSize<span class="hljs-punctuation">,</span> weight.scale <span class="hljs-operator">=</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">,</span> edge.weight.max <span class="hljs-operator">=</span> <span class="hljs-built_in">max</span><span class="hljs-punctuation">(</span>mat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> title.name <span class="hljs-operator">=</span> rownames<span class="hljs-punctuation">(</span>mat<span class="hljs-punctuation">)</span><span class="hljs-punctuation">[</span>i<span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p2.png"></p><h3 id="信号通路层面展示"><a href="#信号通路层面展示" class="headerlink" title="信号通路层面展示"></a>信号通路层面展示</h3><p>信号通路层面的展示，也就是对netp数据槽的展示。</p><ul><li>Hierarchy plot 层次图</li></ul><p>使用层次图可视化通信网络，请定义vertex.receiver，它是一个数字向量，给出作为第一个层次结构图中的目标的细胞组的索引。我们可以使用netVisual_aggregate来可视化信号路径的推断通信网络。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#信号通路展示</span><br>groupSize <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">as.numeric</span><span class="hljs-punctuation">(</span>table<span class="hljs-punctuation">(</span>cellchat<span class="hljs-operator">@</span>idents<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br>cellchat<span class="hljs-operator">@</span>netP<span class="hljs-operator">$</span>pathways<br>pathways.show <span class="hljs-operator">&lt;-</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;MIF&quot;</span><span class="hljs-punctuation">)</span> <br>levels<span class="hljs-punctuation">(</span>cellchat<span class="hljs-operator">@</span>meta<span class="hljs-operator">$</span>celltype<span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 层次图 Hierarchy plot</span><br>vertex.receiver <span class="hljs-operator">=</span> seq<span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span><span class="hljs-punctuation">)</span><br>netVisual_aggregate<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> pathways.show<span class="hljs-punctuation">,</span> vertex.receiver <span class="hljs-operator">=</span> vertex.receiver<span class="hljs-punctuation">,</span> layout <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hierarchy&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p>在层次图中，实体圆和空心圆分别表示源和目标。圆的大小与每个细胞组的细胞数成比例。边缘颜色与信源一致。线越粗，信号越强。这里我们展示了一个MIF信号网络的例子。所有重要的信号通路名称都可以通过cellchat@netP$pathways访问。</p><p>Tips:<a href="https://rdrr.io/github/sqjin/CellChat/man/netVisual_aggregate.html">netVisual_aggregate函数介绍</a></p><p><img src="/2023/05/22/Cellchat/p3.png"><br><img src="/2023/05/22/Cellchat/p4.png"></p><ul><li><p>Circle plot 环状图</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">par<span class="hljs-punctuation">(</span>mfrow<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>netVisual_aggregate<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> pathways.show<span class="hljs-punctuation">,</span> layout <span class="hljs-operator">=</span> <span class="hljs-string">&quot;circle&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p5.png"></p></li><li><p>Chord diagram 和弦图</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">par<span class="hljs-punctuation">(</span>mfrow<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>netVisual_aggregate<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> pathways.show<span class="hljs-punctuation">,</span> layout <span class="hljs-operator">=</span> <span class="hljs-string">&quot;chord&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p6.png"></p></li><li><p>Heatmap 热图</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R">par<span class="hljs-punctuation">(</span>mfrow<span class="hljs-operator">=</span><span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>netVisual_heatmap<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> pathways.show<span class="hljs-punctuation">,</span> color.heatmap <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Reds&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p7.png"></p></li></ul><p>图左侧已经标明了信号发出的细胞群，上方和右方的柱状图分别表示每一列和每一行数值的总和。</p><h3 id="社会网络分析"><a href="#社会网络分析" class="headerlink" title="社会网络分析"></a>社会网络分析</h3><ul><li>计算网络中心性评分</li></ul><p>对于细胞通讯网络进行系统分析，便于我们系统的解释这些复杂的网络。</p><p>使用网络分析中的中心性度量来预测特定细胞类型的关键传入和传出信号，以及不同细胞类型之间的协调响应，可以方便地识别细胞间通信网络中的主要发送者sender、接收者receiver、中介者mediator和影响者influencer。基于计算的MIF信号网络的四个网络中心性指标，Heatmap显示了每个细胞群的相对重要性。</p><p>首先对netp计算网络中心性评分。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R">cellchat <span class="hljs-operator">&lt;-</span> netAnalysis_computeCentrality<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> slot.name <span class="hljs-operator">=</span> <span class="hljs-string">&quot;netP&quot;</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 热图可视化</span><br>netAnalysis_signalingRole_network<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> pathways.show<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p8.png"></p><p>这块涉及到了<a href="https://www.jstatsoft.org/article/view/v024i06">网络分析的一些概念</a>。Cellchat使用加权有向网络的测量方法，包括<strong>出度outdegree</strong>、<strong>入度indegree</strong>，<strong>中介中心性Betweenness</strong>和<strong>信息中心性Information</strong>，上图右侧的模式图是对这些概念的直观展现。</p><p><strong>outdegree</strong>是对出度的衡量，对应着sender，计算的是发出信号的通信概率之和，直观展现就是从紫色圆圈发送信号到周围。</p><p><strong>indegree</strong>是对入度的衡量，对应的是receiver, 橙色的圈接受从四周灰色的圈发出的信号。</p><p><strong>betweenness centrality</strong>来衡量中介中心性,对应着mediator，可以直观的看到粉色圈圈承担了桥梁的作用，就是这个节点相当远一个闸，和它相连的节点想要到其他节点都得经过它。</p><p><strong>Information</strong>这部分也是对中心性的一种度量方式，它使用接近中心性 和 特征向量中心性 的混合度量，综合考虑邻居节点多少和与旁边的节点有多接近，值越高反应对信息流的控制越强。</p><ul><li>热图可视化</li></ul><p>可以使用热图对特定的信号通路的入度和出度进行可视化，识别对某些细胞类群的输出和输入信号贡献最大的信号。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment"># 细胞聚合通讯网络上的信号角色分析</span><br>netAnalysis_signalingRole_scatter<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 热图</span><br>ht1 <span class="hljs-operator">&lt;-</span> netAnalysis_signalingRole_heatmap<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> pattern <span class="hljs-operator">=</span> <span class="hljs-string">&quot;outgoing&quot;</span><span class="hljs-punctuation">)</span><br>ht2 <span class="hljs-operator">&lt;-</span> netAnalysis_signalingRole_heatmap<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> pattern <span class="hljs-operator">=</span> <span class="hljs-string">&quot;incoming&quot;</span><span class="hljs-punctuation">)</span><br>ht1 <span class="hljs-operator">+</span> ht2<br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p9.png"></p><h3 id="通讯模式分析"><a href="#通讯模式分析" class="headerlink" title="通讯模式分析"></a>通讯模式分析</h3><p>除了探索单个通路的详细通讯外，一个重要的问题是多个细胞群和信号通路如何协调运作。</p><p>Cellchat调用了<strong>nmf包</strong>用于对信号通路和细胞群划分模式，功能相似的通路或者信号通路会被归类为同一种模式，通过pattern连接相应的细胞群和信号通路。随着模式数量的增加，可能会出现冗余模式，这使得解释通信模式变得困难。在出度的模式下，我们使用函数selectk来推断模式的数量，包括Cophenetic（共表型系数）和Silhouette（轮廓系数）。这两个度量标准都是基于共识矩阵的层次聚类来衡量特定数量模式的稳定性。</p><p>对于一系列模式的数量，一个合适的模式数量是Cophenetic和Silhouette值开始突然下降的前一个。这里我们来识别一下，这两个系数都是在6的时候明显下降，所以nPatterns应该设置为5，运行这个识别通信模式的函数，我们可以看到，类群和信号都被分为了五部分。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#调用NMF包</span><br>suppressWarnings<span class="hljs-punctuation">(</span>library<span class="hljs-punctuation">(</span>NMF<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment">#识别所有信号通路中的关键信号和潜在的通讯模式（选择模式数量）</span><br>selectK<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> pattern <span class="hljs-operator">=</span> <span class="hljs-string">&quot;outgoing&quot;</span><span class="hljs-punctuation">)</span> <span class="hljs-comment"># incoming</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p10.png"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#查看通讯模式</span><br>identifyCommunicationPatterns<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> pattern <span class="hljs-operator">=</span> <span class="hljs-string">&quot;outgoing&quot;</span><span class="hljs-punctuation">,</span> k <span class="hljs-operator">=</span> nPatterns<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p11.png"></p><p>可以用桑基图和气泡图进行可视化，更直观的看到他们直接的联系。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#桑基图 river plot</span><br>netAnalysis_river<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> pattern <span class="hljs-operator">=</span> <span class="hljs-string">&quot;outgoing&quot;</span><span class="hljs-punctuation">)</span> <br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p12.png"></p><p>我们这里设置pattern 等于outgoing，用于显示输出模式，也就是展示作为信号发送器的细胞如何相互协调，以及它们如何与某些信号通路协调以输出信号。selectK(cellchat, pattern &#x3D; “outgoing”)<br>如果想看输入模式，也就是作为信号接收器的细胞如何相互协调，以及它们如何与某些信号通路协调以响应输入信号，只需要把参数patten 改为 &#x3D;“incoming”即可</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#气泡图 dot plot</span><br>netAnalysis_dot<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> pattern <span class="hljs-operator">=</span> <span class="hljs-string">&quot;outgoing&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p13.png"></p><p>Tips:<br>正常的桑基图如下图，也就是左侧展示了cell group信息，每个细胞群属于哪个pattern,右侧灰色的地方是信号通路，展示了信号通路属于哪个pattern。（查看我们绘制的通讯模式热图可知, 由于数据集没有识别到在pattern 4和pattern 5 中输出模式下贡献度明显升高的信号通路，因此pattern &#x3D; 3可能是更好的选择。Cophenetic和Silhouette只是辅助我们进行parttern数量的选择）<br><img src="/2023/05/22/Cellchat/p14.png"></p><h3 id="基因表达情况分析"><a href="#基因表达情况分析" class="headerlink" title="基因表达情况分析"></a>基因表达情况分析</h3><ul><li>信号通路相关基因的表达模式</li></ul><p>探索了信号通路之后，我们可以再去细致的挖掘，信号通路相关的基因的表达模式，可以使用小提琴图和气泡图可视化，<br>仍然以MIF信号通路为例，使用小提琴和气泡图进行该通路下通路相关基因的表达情况。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#信号通路相关基因的表达模式</span><br><span class="hljs-comment">#小提琴图</span><br>plotGeneExpression<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MIF&quot;</span><span class="hljs-punctuation">,</span> type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;violin&quot;</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#气泡图</span><br>plotGeneExpression<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span>signaling <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MIF&quot;</span><span class="hljs-punctuation">,</span> type <span class="hljs-operator">=</span> <span class="hljs-string">&quot;dot&quot;</span><span class="hljs-punctuation">,</span> color.use <span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p15.png"></p><ul><li>整体气泡图</li></ul><p>我们也可以对由多个受配体或信号通路介导的细胞间通讯<strong>整体</strong>进行可视化，气泡图绘制了（全部配体-受体及相关信号通路）</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#可视化由多个受配体或信号通路介导的细胞间通讯（整体）</span><br><span class="hljs-comment">#气泡图</span><br>netVisual_bubble<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> remove.isolate <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">,</span> return.data <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p16.png"></p><ul><li>整体和弦图</li></ul><p>Tips:Chord diagram的两种模式</p><p>netVisual_chord_cell可视化<strong>不同细胞群之间的</strong>细胞-细胞通信(其中弦图中的每个扇区是一个细胞群).</p><p>netVisual_chord_gene可视化<strong>由多个配体-受体或信号通路介导的细胞-细胞通信</strong>(其中弦图中的每个扇区是一个配体、受体或信号通路)</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#可视化由多个受配体或信号通路介导的细胞间通讯（整体）</span><br><span class="hljs-comment">#和弦图</span><br>netVisual_chord_gene<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> lab.cex <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span><span class="hljs-punctuation">,</span>legend.pos.y <span class="hljs-operator">=</span> <span class="hljs-number">30</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p17.png"></p><h3 id="个性化绘图"><a href="#个性化绘图" class="headerlink" title="个性化绘图"></a>个性化绘图</h3><p>个性化绘制指定受配体或信号通路介导的细胞间通讯，比如我们将发出信号的细胞类型局限为T细胞，接收信号的细胞类型设置为monocyte, B细胞和pre B。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#可视化由指定受配体或信号通路介导的细胞间通讯（个性化）</span><br><span class="hljs-comment">#配受体写法 &quot;配体-受体&quot;</span><br><span class="hljs-comment"># 气泡图</span><br>netVisual_bubble<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> sources.use <span class="hljs-operator">=</span> <span class="hljs-string">&quot;T_cells&quot;</span><span class="hljs-punctuation">,</span> targets.use <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;Monocyte&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;B_cell&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Pre-B_cell_CD34-&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> remove.isolate <span class="hljs-operator">=</span> <span class="hljs-literal">FALSE</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#sources.use = NULL, targets.use = NULL, signaling = NULL, pairLR.use = NULL</span><br>pairLR.use <span class="hljs-operator">&lt;-</span> extractEnrichedLR<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> signaling <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;TNF&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;IL16&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br>netVisual_bubble<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> sources.use <span class="hljs-operator">=</span>  <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;T_cells&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Monocyte&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> targets.use <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;Monocyte&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;B_cell&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;Pre-B_cell_CD34-&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;CMP&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> pairLR.use <span class="hljs-operator">=</span> pairLR.use<span class="hljs-punctuation">,</span> remove.isolate <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure><p><img src="/2023/05/22/Cellchat/p18.png"></p><h3 id="多组比较"><a href="#多组比较" class="headerlink" title="多组比较"></a>多组比较</h3><p>由于我们本次的数据集细胞数量较少，且细胞在组间分布不均匀，后续就不进行个性化展示。</p><p>多组比较和之前的思路相似，先按组别进行拆分，然后分别对各组cellchat进行细胞通讯分析即可。使用netVisual_diffInteraction计算两组之间通讯概率的差值，并进行展示。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#多组比较</span><br><span class="hljs-comment"># 根据orig.ident拆分seurat对象</span><br>sp <span class="hljs-operator">&lt;-</span> SplitObject<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">,</span> split.by <span class="hljs-operator">=</span> <span class="hljs-string">&quot;orig.ident&quot;</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment"># 根据group创建cellchat对象</span><br>cellchat_A <span class="hljs-operator">&lt;-</span> createCellChat<span class="hljs-punctuation">(</span>object <span class="hljs-operator">=</span> sp<span class="hljs-punctuation">[[</span><span class="hljs-string">&quot;HNC01TIL&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> group.by <span class="hljs-operator">=</span> <span class="hljs-string">&quot;celltype&quot;</span><span class="hljs-punctuation">)</span><br>cellchat_B <span class="hljs-operator">&lt;-</span> createCellChat<span class="hljs-punctuation">(</span>object <span class="hljs-operator">=</span> sp<span class="hljs-punctuation">[[</span><span class="hljs-string">&quot;Tonsil2&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> group.by <span class="hljs-operator">=</span> <span class="hljs-string">&quot;celltype&quot;</span><span class="hljs-punctuation">)</span><br><span class="hljs-comment">#由于分组之后Cellchat_B的部分celltype缺失细胞，故需要先droplevels处理</span><br>cellchat_B<span class="hljs-operator">@</span>meta<span class="hljs-operator">$</span>celltype <span class="hljs-operator">=</span> droplevels<span class="hljs-punctuation">(</span>cellchat_B<span class="hljs-operator">@</span>meta<span class="hljs-operator">$</span>celltype<span class="hljs-punctuation">)</span><br><br>cellchat_A<span class="hljs-operator">@</span>idents <span class="hljs-operator">=</span> droplevels<span class="hljs-punctuation">(</span>cellchat_A<span class="hljs-operator">@</span>idents<span class="hljs-punctuation">)</span><br>cellchat_B<span class="hljs-operator">@</span>idents <span class="hljs-operator">=</span> droplevels<span class="hljs-punctuation">(</span>cellchat_B<span class="hljs-operator">@</span>idents<span class="hljs-punctuation">)</span><br><br><br><span class="hljs-comment">#多组比较</span><br><span class="hljs-comment"># 分别对各组cellchat进行细胞通讯分析 ####</span><br>cellchat_list<span class="hljs-operator">=</span> <span class="hljs-built_in">list</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><br><span class="hljs-keyword">for</span> <span class="hljs-punctuation">(</span>i <span class="hljs-keyword">in</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span>cellchat_A<span class="hljs-punctuation">,</span>cellchat_B<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">&#123;</span><br>  cellchat <span class="hljs-operator">=</span> i<br>  name <span class="hljs-operator">=</span> unique<span class="hljs-punctuation">(</span>i<span class="hljs-operator">@</span>meta<span class="hljs-operator">$</span>orig.ident<span class="hljs-punctuation">)</span><br>  CellChatDB <span class="hljs-operator">&lt;-</span> CellChatDB.human <br>  CellChatDB.use <span class="hljs-operator">&lt;-</span> CellChatDB<br>  CellChatDB.use <span class="hljs-operator">&lt;-</span> subsetDB<span class="hljs-punctuation">(</span>CellChatDB<span class="hljs-punctuation">,</span> search <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Secreted Signaling&quot;</span><span class="hljs-punctuation">)</span><br>  cellchat<span class="hljs-operator">@</span>DB <span class="hljs-operator">&lt;-</span> CellChatDB.use<br>  cellchat <span class="hljs-operator">&lt;-</span> CellChat<span class="hljs-operator">::</span>subsetData<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span> <br>  cellchat <span class="hljs-operator">&lt;-</span> identifyOverExpressedGenes<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br>  cellchat <span class="hljs-operator">&lt;-</span> identifyOverExpressedInteractions<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br>  cellchat <span class="hljs-operator">&lt;-</span> computeCommunProb<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br>  cellchat <span class="hljs-operator">&lt;-</span> filterCommunication<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">,</span> min.cells <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-punctuation">)</span><br>  cellchat <span class="hljs-operator">&lt;-</span> computeCommunProbPathway<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br>  cellchat <span class="hljs-operator">&lt;-</span> aggregateNet<span class="hljs-punctuation">(</span>cellchat<span class="hljs-punctuation">)</span><br>  cellchat_list<span class="hljs-punctuation">[[</span>name<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> cellchat<br><span class="hljs-punctuation">&#125;</span><br><span class="hljs-comment"># 合并cellchat list</span><br>cellchat <span class="hljs-operator">&lt;-</span> mergeCellChat<span class="hljs-punctuation">(</span>cellchat_list <span class="hljs-punctuation">,</span> add.names <span class="hljs-operator">=</span> <span class="hljs-built_in">names</span><span class="hljs-punctuation">(</span>cellchat_list<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Monocle2</title>
    <link href="/2023/05/19/Monocle2/"/>
    <url>/2023/05/19/Monocle2/</url>
    
    <content type="html"><![CDATA[<p>Monocle2的学习笔记及代码分享</p><span id="more"></span><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>在研究胚胎发育，细胞转化以及干细胞在再生和疾病中的功能等领域，通过<a href="https://www.molcells.org/journal/view.html?doi=10.14348/molcells.2019.0006">谱系追踪</a>来研究单个细胞及其后代的命运是常见的研究方法。传统的谱系追踪涉及用染料显微注射到单个细胞或细胞群中以观察细胞迁移，或用利用Cre-LoxP 位点特异性重组系统对细胞命运进行追踪展示等基于成像的方法（Imageing-gased approaches）。</p><p>在NGS测序出现后，使用计算手段来追踪或重建细胞谱系对谱系追踪领域影响巨大。基于scRNA-seq，还可以在进行建立细胞谱系的同时分析基因表达模式。</p><p>由于细胞分化或细胞成熟等细胞进程在生物进程中并不总是以一种分散的状态，比如clustering，进行的，而更多是一种动态的，连续的发育状态。因此，很多<a href="https://github.com/agitter/single-cell-pseudotime">计算方法</a>致力于将细胞投射到一个连续路径上（Pseudotime）来展示细胞的发育轨迹。</p><p>下图为拟时序分析的简单<a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005212">示例图</a><br><img src="/2023/05/19/Monocle2/scRNA_pseudotime_estimation_problem.png"></p><p><img src="/2023/05/19/Monocle2/plot1.png"></p><h2 id="Monocle介绍"><a href="#Monocle介绍" class="headerlink" title="Monocle介绍"></a>Monocle介绍</h2><h3 id="软件目的"><a href="#软件目的" class="headerlink" title="软件目的:"></a>软件目的:</h3><p>1: 对从细胞身份转化的过程进行建模（从一个clusters进展到另一个cluster），研究分化过程。</p><p>2: 可以使用轨迹之间的差异来识别与轨迹转变相关的基因</p><p>注意：推断的轨迹过程有时不一定反应真实的生物学过程，需要结合其他生物学先验知识和证据来对轨迹进行解释。</p><h3 id="研发历史"><a href="#研发历史" class="headerlink" title="研发历史"></a>研发历史</h3><h4 id="2014年-Nature-Biotechnology"><a href="#2014年-Nature-Biotechnology" class="headerlink" title="2014年 Nature Biotechnology"></a><a href="https://doi.org/10.1038/nbt.2859">2014年 Nature Biotechnology</a></h4><p>monocle的概念版本发表在2014年，这个时间点，基于微流控的高通量的单细胞测序技术，比如droplet-based的scRNA-seq技术都还没有发表，商业化的10X单细胞测序也还未出现，此时的单细胞测序还是通过显微成像或者流式细胞技术进行细胞水平的研究。因此这个版本的Monocle针对的其实是低细胞数的轨迹（trajectory）分析。虽然和现在的10X单细胞测序动辄能测上万细胞的通量相比，当时用作分析的细胞数也就是几百个，相比之下低了太多，但就算如此，bulk RNA seq转录组测序的差异表达基因算法仍然不适用与单细胞测序。因为Bulk RNA-seq测序数据的差异分析通常采用基于平均值或方差的假设检验方法，无法捕捉到单个细胞水平的表达动态。</p><p>Monocle1，Monocle的初始版本，是第一个发布的单细胞RNA测序数据分析软件包之一，它认为就算单细胞测序是在同一时间捕获到的细胞群体，它也可能包括许多不同的中间分化状态，传统转录组那种只考虑其平均值的算法会掩盖在单个细胞中发生的趋势。</p><p><img src="/2023/05/19/Monocle2/banana.png"></p><p>Monocle基于一个基本假设：scRNA - Seq中的所有细胞存在潜在的时间顺序，由于分化不同步使得细胞的基因表达水平存在很强的差异性，那就可以根据这个潜在的动态过程对细胞进行排序。Monocle的算法源自先前的基于bulk RNASeq重构样本间的时间顺序的算法，但将其扩展到单细胞层面，并允许单个祖细胞类型存在多个细胞命运。</p><p>Monocle引入了一个概念： “pseudotime”， 即通过生物过程进展的定量测量，在’pseudotime拟时间’中排序单细胞表达谱。或者说是细胞在发育过程中的时间顺序。monocle1可以根据基因表达数据生成拓扑图，确定基因表达水平的变化趋势，并可视化地展示出细胞发育轨迹，从而更容易理解和解释单细胞RNA-seq数据的结果。</p><p>热图展示了Monocle找到的差异基因(行)，细胞(列)按拟时间顺序排列。<br><img src="/2023/05/19/Monocle2/heatmap1.png"></p><p>工作原理图<br><img src="/2023/05/19/Monocle2/algorithm1.png"></p><h4 id="2017年-Nature-Methods-1月"><a href="#2017年-Nature-Methods-1月" class="headerlink" title="2017年 Nature Methods (1月)"></a><a href="https://doi.org/10.1038/nmeth.4150">2017年 Nature Methods (1月)</a></h4><p>随着测序技术的发展，高通量的单细胞测序技术产生了，单细胞测序可以检测到更多的细胞和更多的基因表达水平。为了适应这种变化，monocle2，在2017年被发表在nature methods上。这个版本的monocle对之前算法进行了进一步优化，增加了用于分支分析的BEAM算法。</p><p><strong>Branched expression analysis modeling (BEAM)</strong></p><p>为了以稳健的方式从学习到的轨迹中检测细胞命运依赖基因，作者开发了BEAM，一种广义线性模型，用于找到分支之间不同的所有基因，（其实就是一种差异分析方法）。什么是分支呢，就是当发育过程中，细胞执行不同的基因表达程序时，这个时候就是细胞做出命运抉择的时刻。当细胞做出命运选择时，分支就会出现在轨迹中: 一个发育谱系沿着一条路径前进，而另一个谱系产生第二条路径。BEAM算法就可以用来识别在每个谱系分岔过程中表现出显著差异的基因，帮助确定在复杂的生物学过程中细胞命运决定的时刻。</p><p>BEAM方法接受一个已通过orderCells函数排序的CellDataSet以及发育轨迹中分支点的名称作为输入，返回每个基因的显着性得分表。得分显着的基因在其表达中被认为是分支依赖性的。</p><p>下图展示了’pseudotime拟时间”排序后的细胞轨迹，可以看到上面有黑色的圆圈，是分支点1， branch_point 1，也就是细胞分化细胞命运决定的时刻。<br><img src="/2023/05/19/Monocle2/p1.png"></p><p>图中简单展示了Beam算法的原理，它使用广义线性模型对已知分支值的数据进行回归(alternative model)，为每个分支拟合单独的曲线。它还通过对所有数据拟合一条曲线来执行分支指派未知的回归(零模型)，然后通过似然比检验比较这些模型。 判断当细胞从树的左上角(E14.5)的早期发育阶段通过分支时，哪些基因发生了变化？哪些基因在分支之间差异表达？<br><img src="/2023/05/19/Monocle2/p2.png"></p><p>可以看到分化的关键基因（marker基因）Pdpn and Sftpb在明显属于随不同branch变化的基因， 两个分支之间呈现出了显著差异的趋势，但housekeeping genes (Hprt and Pgk1)并未有明显差异。<br><img src="/2023/05/19/Monocle2/p3.png"></p><h4 id="2017年-Nature-Methods-8月"><a href="#2017年-Nature-Methods-8月" class="headerlink" title="2017年 Nature Methods (8月)"></a><a href="https://doi.org/10.1038/nmeth.4402">2017年 Nature Methods (8月)</a></h4><p>这篇文献主要讲述了Monocle2的工作流程，介绍了如何将反向图嵌入引入细胞轨迹分析，并改为使用DDRTree的算法做降维。monocle2的稳定版本从此开发出来，它也成为了单细胞领域目前应用最广泛的轨迹推断方法。</p><p>monocle2的流程图<br><img src="/2023/05/19/Monocle2/p4.png"></p><p>关键步骤：</p><ol><li>选择定义过程的基因: 在单细胞测序中，会出现很多低水平表达的基因，造成一个噪声的影响，因此我们在分析的时候不能选择使用全部的基因分析。推断单细胞的轨迹是一个机器学习的问题，轨迹推断的第一步就是选择monocle使用哪些基因作为轨迹推断的关键基因。也就是机器学习中的特征选择问题。</li></ol><p>Monocle2首先使用了”dpFeature”方法确认与生物过程相关的基因（这些基因在下游分析时被称为ordering gene），注意一下，这里与BEAM这个寻找分叉点相关基因的算法不同，dpFeatures找到的是全局的拟时相关基因，也就是拟时起点和终点相关的基因。</p><ol start="2"><li><p>每个细胞被表示为高维空间(x)中的一个点，其中每个维度对应一个基因的表达水平。数据从高维空间(X)被投影到低维空间(z)上，使用k - means聚类算法找到这些细胞的分群中心，然后通过反向图嵌入（默认是DDRTree）的流形学习算法，找到高维基因表达空间与低维空间的映射关系并构建最小生成树，将细胞投影到生成树上，并将找到的中心进行连接，构建初步的树形结构。</p></li><li><p>基于新的细胞位置，更新细胞的分群中心和轨迹结构，将二维空间中的树（二维轨迹），重新投射到高维空间。迭代此过程，直至收敛（即获得稳定的树形结构，细胞轨迹可以反应原始数据的特征）。</p></li></ol><p>这里提到了两个关键词，dpFeature, 用于确认与生物过程相关的基因，也就是ordering gene。以及DDRTree，在monocle的reduceDimension函数中默认使用，用来推断基因表达动态变化，这两个算法是monocle2的主打点。</p><p>其实目前monocle已经更新到3代了，但考虑到目前发表的文章还是使用monocle2的比较多，而且monocle3的下游可视化方式还有待开发，我们仍然使用monocle2进行讲解。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li><p>挖掘细胞分化的关键基因：<br>在分化或发育研究中，可通过拟时序分析关键的分化节点，挖掘细胞不同分化路径命运选择的推动基因</p></li><li><p>揭示细胞发育轨迹：<br>对于未知的细胞间或细胞亚群，通过拟时序分析揭示细胞分化轨迹，推测干细胞在发育过程的分化轨迹或某类细胞的分化来源</p></li><li><p>揭示细胞动态变化：<br>在肿瘤或免疫研究中，通过拟时序分析追踪细胞的动态变化，推断细胞亚型的演变轨迹或细胞凋亡路径</p></li></ul><h3 id="代码关键步骤讲解"><a href="#代码关键步骤讲解" class="headerlink" title="代码关键步骤讲解"></a>代码关键步骤讲解</h3><p>monocle2 <a href="https://github.com/cole-trapnell-lab/monocle-release/tree/master">github</a><br>monocle <a href="https://rdrr.io/bioc/monocle/">R包说明文档</a></p><ol><li><p>CellDataSet对象构建与预处理</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#可选方案: 从表达量矩阵和细胞、基因的表型文件构建CellDataSet对象</span><br><br><span class="hljs-comment">#1. expr_matrix</span><br><span class="hljs-comment">#行为基因，列为细胞的表达量矩阵</span><br><span class="hljs-comment">#2. phenoData</span><br><span class="hljs-comment">#对应的细胞的标签信息（barcodes)</span><br><span class="hljs-comment">#3. featureData</span><br><span class="hljs-comment">#对应的基因的标签信息，其中必须包含“gene_short_name”列</span><br><br><span class="hljs-comment">##pd, phenoData</span><br>pd <span class="hljs-operator">&lt;-</span> new<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;AnnotatedDataFrame&quot;</span><span class="hljs-punctuation">,</span> data <span class="hljs-operator">=</span> seurat_ob<span class="hljs-operator">@</span>meta.data<span class="hljs-punctuation">)</span> <br><span class="hljs-comment">##fd, featureData</span><br>gene_annotation<span class="hljs-operator">=</span>data.frame<span class="hljs-punctuation">(</span>gene_short_name <span class="hljs-operator">=</span> rownames<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-operator">@</span>assays<span class="hljs-operator">$</span>RNA<span class="hljs-operator">@</span>counts<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>                           stringsAsFactors<span class="hljs-operator">=</span><span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span><br>rownames<span class="hljs-punctuation">(</span>gene_annotation<span class="hljs-punctuation">)</span><span class="hljs-operator">&lt;-</span>gene_annotation<span class="hljs-operator">$</span>gene_short_name<br>fd <span class="hljs-operator">&lt;-</span> new<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;AnnotatedDataFrame&quot;</span><span class="hljs-punctuation">,</span> data <span class="hljs-operator">=</span> gene_annotation<span class="hljs-punctuation">)</span>    <br><br>gbm_cds <span class="hljs-operator">&lt;-</span> newCellDataSet<span class="hljs-punctuation">(</span>GetAssayData<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">,</span>slot<span class="hljs-operator">=</span><span class="hljs-string">&quot;counts&quot;</span><span class="hljs-punctuation">,</span>assay<span class="hljs-operator">=</span><span class="hljs-string">&quot;RNA&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><br>                       phenoData <span class="hljs-operator">=</span> pd<span class="hljs-punctuation">,</span><br>                       featureData <span class="hljs-operator">=</span> fd<span class="hljs-punctuation">,</span><br>                    expressionFamily<span class="hljs-operator">=</span>negbinomial.size<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#推荐方案</span><br><span class="hljs-comment">#从Seurat聚类结果构建CellDataSet对象</span><br><br>cds <span class="hljs-operator">&lt;-</span> as.CellDataSet<span class="hljs-punctuation">(</span>seurat_ob<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#size facotr帮助我们标准化细胞之间的mRNA的差异。</span><br><span class="hljs-comment">#离散度值可以帮助我们进行后续的差异分析。</span><br>cds <span class="hljs-operator">&lt;-</span> estimateSizeFactors<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">)</span><br>cds <span class="hljs-operator">&lt;-</span> estimateDispersions<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#过滤低质量细胞(保留至少在1个细胞中counts大于1的基因）</span><br>cds <span class="hljs-operator">=</span>  detectGenes<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">,</span>min_expr <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#保留至少在10个细胞中表达的基因</span><br>expressed_genes <span class="hljs-operator">=</span> row.names<span class="hljs-punctuation">(</span>subset<span class="hljs-punctuation">(</span>fData<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>num_cells_expressed<span class="hljs-operator">&gt;</span><span class="hljs-number">10</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure></li><li><p>寻找生物学过程相关的基因</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#推荐方案: 使用monocle的dpFeature方法</span><br><span class="hljs-comment">#differentialGeneTest函数即为monocle的dpFeature方法，用于确认与生物过程相关的基因（即与clusters分群相关的差异基因）</span><br><span class="hljs-comment">#The group design to find ordering genes, 这里使用的是seurat的clusters</span><br>clustering_DEGs <span class="hljs-operator">=</span> differentialGeneTest<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">[</span>expressed_genes<span class="hljs-punctuation">,</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>fullModelFormulaStr <span class="hljs-operator">=</span><span class="hljs-string">&quot;~clusters&quot;</span><span class="hljs-punctuation">,</span>cores <span class="hljs-operator">=</span> <span class="hljs-number">4</span><span class="hljs-punctuation">)</span><br>featureData<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">)</span><span class="hljs-operator">@</span>data<span class="hljs-punctuation">[</span>rownames<span class="hljs-punctuation">(</span>clustering_DEGs<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;pval&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">=</span>clustering_DEGs<span class="hljs-operator">$</span>pval<br>featureData<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">)</span><span class="hljs-operator">@</span>data<span class="hljs-punctuation">[</span>rownames<span class="hljs-punctuation">(</span>clustering_DEGs<span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span><span class="hljs-string">&quot;qval&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-operator">=</span>clustering_DEGs<span class="hljs-operator">$</span>qval<br><br><span class="hljs-comment">#根据qval筛选ordering gene</span><br>ordering_genes <span class="hljs-operator">&lt;-</span> row.names <span class="hljs-punctuation">(</span>subset<span class="hljs-punctuation">(</span>clustering_DEGs<span class="hljs-punctuation">,</span> qval <span class="hljs-operator">&lt;</span> <span class="hljs-number">0.01</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#一旦我们有用于Ordering的基因ID列表，我们就需要将它们设置在cds对象中</span><br>gbm_cds <span class="hljs-operator">=</span> setOrderingFilter<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">,</span>ordering_genes <span class="hljs-operator">=</span> ordering_genes<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#可以使用fData(gbm_cds)查看，基因矩阵中增加了一列use_for_ordering列</span><br>plot_ordering_genes<span class="hljs-punctuation">(</span>gbm_cds<span class="hljs-punctuation">)</span><br><br><span class="hljs-comment">#可选方案:选择方差最大的基因</span><br>disp_table <span class="hljs-operator">&lt;-</span> dispersionTable<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">)</span><br>ordering_genes <span class="hljs-operator">&lt;-</span> subset<span class="hljs-punctuation">(</span>disp_table<span class="hljs-punctuation">,</span><br>                         mean_expression <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0.5</span> <span class="hljs-operator">&amp;</span><br>                           dispersion_empirical <span class="hljs-operator">&gt;=</span> <span class="hljs-number">1</span> <span class="hljs-operator">*</span> dispersion_fit<span class="hljs-punctuation">)</span><span class="hljs-operator">$</span>gene_id<br><span class="hljs-comment">#将ordering gene设置在cds对象</span><br>gbm_cds <span class="hljs-operator">&lt;-</span> setOrderingFilter<span class="hljs-punctuation">(</span>cds<span class="hljs-punctuation">,</span> ordering_genes<span class="hljs-punctuation">)</span><br>plot_ordering_genes<span class="hljs-punctuation">(</span>gbm_cds<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure></li><li><p>构建生成树</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs R"><span class="hljs-comment">#the dependent package irlba should not be less than 2.3.2, or the following step will fail</span><br><span class="hljs-comment">#if the size of cells is big.</span><br>gbm_cds <span class="hljs-operator">=</span> reduceDimension<span class="hljs-punctuation">(</span>gbm_cds<span class="hljs-punctuation">,</span>max_components <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span>verbose <span class="hljs-operator">=</span> <span class="hljs-built_in">T</span><span class="hljs-punctuation">)</span><br>gbm_cds <span class="hljs-operator">=</span> orderCells<span class="hljs-punctuation">(</span>gbm_cds<span class="hljs-punctuation">,</span>reverse <span class="hljs-operator">=</span> <span class="hljs-built_in">F</span><span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure></li><li><p>可视化结果展示<br>轨迹图<br><img src="/2023/05/19/Monocle2/vis1.png" alt="轨迹图"><br>基因表达量<br><img src="/2023/05/19/Monocle2/vis2.png" alt="基因表达量"><br>动力学趋势图<br><img src="/2023/05/19/Monocle2/vis3.png" alt="动力学趋势图"><br>热图<br><img src="/2023/05/19/Monocle2/vis4.png" alt="热图"></p></li><li><p>进阶练习：将基因表达量映射到拟时序轨迹上<br><img src="/2023/05/19/Monocle2/high.png"></p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs R">Dims <span class="hljs-operator">=</span> as.data.frame<span class="hljs-punctuation">(</span>t<span class="hljs-punctuation">(</span>monocle<span class="hljs-operator">::</span>reducedDimS<span class="hljs-punctuation">(</span>gbm_cds<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span> rownames_to_column<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;Barcodes&quot;</span><span class="hljs-punctuation">)</span><br>colnames<span class="hljs-punctuation">(</span>Dims<span class="hljs-punctuation">)</span><span class="hljs-punctuation">[</span><span class="hljs-number">2</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Component1&quot;</span><br>colnames<span class="hljs-punctuation">(</span>Dims<span class="hljs-punctuation">)</span><span class="hljs-punctuation">[</span><span class="hljs-number">3</span><span class="hljs-punctuation">]</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Component2&quot;</span><br><br>i<span class="hljs-operator">=</span> to_be_tested<span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-punctuation">]</span><br>data <span class="hljs-operator">=</span> FetchData<span class="hljs-punctuation">(</span>object <span class="hljs-operator">=</span> seurat_ob<span class="hljs-punctuation">,</span> vars <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;clusters&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-built_in">as.character</span><span class="hljs-punctuation">(</span>i<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">%&gt;%</span> rownames_to_column<span class="hljs-punctuation">(</span><span class="hljs-string">&quot;Barcodes&quot;</span><span class="hljs-punctuation">)</span><br><br><br>data_df <span class="hljs-operator">&lt;-</span> merge<span class="hljs-punctuation">(</span>data<span class="hljs-punctuation">,</span>Dims<span class="hljs-punctuation">,</span> by<span class="hljs-operator">=</span><span class="hljs-string">&quot;Barcodes&quot;</span><span class="hljs-punctuation">)</span><br><br>g <span class="hljs-operator">&lt;-</span> ggplot<span class="hljs-punctuation">(</span>data<span class="hljs-operator">=</span>data_df<span class="hljs-punctuation">,</span> aes<span class="hljs-punctuation">(</span>x<span class="hljs-operator">=</span>Component1<span class="hljs-punctuation">,</span> y<span class="hljs-operator">=</span>Component2<span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span> <span class="hljs-operator">+</span> geom_point<span class="hljs-punctuation">(</span>aes<span class="hljs-punctuation">(</span>color<span class="hljs-operator">=</span>data_df<span class="hljs-punctuation">[[</span>i<span class="hljs-punctuation">]</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span> size<span class="hljs-operator">=</span><span class="hljs-number">1.5</span><span class="hljs-punctuation">,</span> na.rm <span class="hljs-operator">=</span> <span class="hljs-literal">TRUE</span><span class="hljs-punctuation">)</span><span class="hljs-operator">+</span>theme_classic<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-operator">+</span> scale_color_gradientn<span class="hljs-punctuation">(</span>colours <span class="hljs-operator">=</span> <span class="hljs-built_in">c</span><span class="hljs-punctuation">(</span><span class="hljs-string">&quot;grey&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;yellow&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;red&quot;</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">+</span>theme<span class="hljs-punctuation">(</span>legend.text <span class="hljs-operator">=</span> element_text<span class="hljs-punctuation">(</span>size <span class="hljs-operator">=</span> <span class="hljs-number">10</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>legend.title <span class="hljs-operator">=</span> element_blank<span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">,</span>plot.title <span class="hljs-operator">=</span> element_text<span class="hljs-punctuation">(</span>hjust <span class="hljs-operator">=</span> <span class="hljs-number">0.5</span><span class="hljs-punctuation">)</span><span class="hljs-punctuation">)</span><span class="hljs-operator">+</span>labs<span class="hljs-punctuation">(</span>title <span class="hljs-operator">=</span> i<span class="hljs-punctuation">)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="其他拟时序软件介绍"><a href="#其他拟时序软件介绍" class="headerlink" title="其他拟时序软件介绍"></a>其他拟时序软件介绍</h2><h3 id="RNA-velocity-RNA速率"><a href="#RNA-velocity-RNA速率" class="headerlink" title="RNA velocity (RNA速率)"></a>RNA velocity (RNA速率)</h3><p>分子生物学上我们都知道，刚转录出的mRNA包含外显子和内含子，经过剪接切除内含子后，得到用于编码蛋白的成熟mRNA，最后经过降解消除。在单细胞测序中，可以很容易观测到剪接的发生，例如跨外显子&#x2F;内含子的reads可表示未剪接的pre-mRNA，跨外显子&#x2F;外显子的reads可表示剪接的成熟mRNA，通过Cellranger软件，也就是在下机数据与基因组比对的初始处理步骤中，可针对所有基因的每个细胞产生剪接和非剪接RNA数量进行计数。如果转录速率恒定，那RNA的丰度（也就是RNA velocity）只由未成熟转向成熟，以及成熟后的降解两个因素所决定。通过计算剪接和未剪接的mRNA分子数，我们就可以间接的估算基因的转录速率。对于某个基因来说，如果它新生的RNA”耗尽”了，就表示这个基因的表达被下调，而未成熟mRNA的积累表示这个基因的表达被上调。</p><p>如图所示，RNA velocity的基本原理：先是计算所有基因的每个细胞的剪接和未剪接计数，然后推断合适的转录动力学模型。通过计算未剪接转录本和剪接转录本之间的比率可以推断细胞命运的状态(过渡与稳定)和方向性(轨迹)。<br><img src="/2023/05/19/Monocle2/velocity.png"><br>使用RNA速率分析，就可以计算细胞内mRNA剪接前后比例来估计RNA丰度随时间的变化，推断转录事件的时间顺序，估算RNA相关的转录剪切降解速率，在<strong>无需先验知识</strong>的情况下，推断细胞的下一个可能的分化方向。</p><p>RNA velocity可以揭示单细胞基因表达在时间尺度上的动态变化，这种动态变化与人类和其他哺乳动物的发育、再生和反应过程相匹配。它是一种局部速度向量，可用于模型定型、命运选择和体内转录的精确动力学研究，能够详细研究复杂组织和器官的动态过程，并将极大地促进人类胚胎的谱系分析。</p><p>RNA velocity的方法的具体实现通常是通过velocyto和scVelo，由于scVelo软件包的维护做的比较好，并且引入了更优化的模型，基于似然的动力学模型，所以scVelo会更常用一些。由于RNA velocity的环境配置比较复杂，仅做原理讲解，不做实操展示。</p><p>应用场景：</p><ul><li><p>动力学研究：<br>模型定型、命运选择和体内转录的精确动力学研究</p></li><li><p>揭示细胞动态变化：<br>能够详细研究复杂组织和器官的动态过程，</p></li><li><p>谱系分析：<br>人类胚胎的谱系分析</p></li></ul><h3 id="Diffusion-map"><a href="#Diffusion-map" class="headerlink" title="Diffusion map"></a>Diffusion map</h3><p>回忆一下之前谈到的monocle的原理，monocle2依赖differentialGeneTest方法，需要现有一个分组的信息才能进行轨迹构建。但diffusion map与monocle2不同，diffusion map不需要clusters等信息，不需要根据特定的属性对细胞进行分组聚类。因此，Diffusion map可以保留连续的分化轨迹。</p><p>Diffusion Map通过马尔科夫链的概率策略来对单细胞数据进行建模，判断细胞转移的方向，将细胞间的空间结构降维并映射为连续性结构。算法层面相对简单，比较适用于研究样本集中单个细胞的分化或者谱系起源，或者针对从不同时间点取到的相同类型的细胞进行时序分析。对于复杂的数据集或者可能存在分支的数据集，不建议使用。</p><p><img src="/2023/05/19/Monocle2/diffusion1.png"><br>基本原理：</p><ol><li>输入细胞*基因的（n x G）矩阵，和monocle类似，变到高维空间</li><li>通过高斯核函数，高斯核函数定义成对数据点之间的相似度矩阵。从G维基因空间中找到由较高概率密度的连续路径所组成的扩散路径。</li><li>根据细胞对之间的转移概率，计算 n × n 的细胞间马尔可夫转移概率矩阵 。（如果对数据进行随机游走，则走到附近的数据点比走到远处的另一个数据点更有可能，也就是概率更高）</li><li>对马尔可夫转移概率矩阵进行特征值分解， 获得特征向量（一般取前三维度），获得细胞在不同维度的坐标。</li></ol><p>通过扩散映射将空间距离转换为状态转移的概率，对不同分化路径中的细胞进行降维和排序，确定分化细胞的随机转移方向，进而预测细胞的发育轨迹并检测稀有种群。可以与RNA velocity共同进行分析，做相互验证。</p><p>基于Diffusion maps算法开发的<a href="https://doi.org/10.1093/bioinformatics/btv715">destiny软件</a>发表在bioinformatics，因为destiny包可以兼容seurat包且与其他方法相比，diffusion map算法对噪声扰动具有鲁棒性并且计算成本低(内存消耗远小于monocle)，可以将细胞间非线性的空间结构降维并映射维连续性结构。相关文献已经被引用超过1000次，也是一个稳定的分析方法了。</p><p>结果展示：<br><img src="/2023/05/19/Monocle2/diffusion2.png"></p>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo常用命令</title>
    <link href="/2023/05/19/Hexo-personal-design/"/>
    <url>/2023/05/19/Hexo-personal-design/</url>
    
    <content type="html"><![CDATA[<p>本文保存常用的hexo配置与命令。</p><span id="more"></span><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h3 id="创建新的文章页面（名称为Hexo-personal-design）"><a href="#创建新的文章页面（名称为Hexo-personal-design）" class="headerlink" title="创建新的文章页面（名称为Hexo_personal_design）"></a>创建新的文章页面（名称为Hexo_personal_design）</h3><pre><code class="hljs">hexo new post Hexo_personal_design</code></pre><h3 id="在-config-yml中进行如下配置，可在"><a href="#在-config-yml中进行如下配置，可在" class="headerlink" title="在_config.yml中进行如下配置，可在"></a>在_config.yml中进行如下配置，可在</h3><pre><code class="hljs">post_asset_folder: truemarked:    prependRoot: true    postAsset: true#在/source/_posts/Hexo_personal_design文件夹中存放background.jpg文件夹并通过如下命令进行调用。![](backgroud.jpg)</code></pre><h3 id="在文章修改完成后使用命令进行推送到git-使用cmd"><a href="#在文章修改完成后使用命令进行推送到git-使用cmd" class="headerlink" title="在文章修改完成后使用命令进行推送到git(使用cmd)"></a>在文章修改完成后使用命令进行推送到git(使用cmd)</h3><pre><code class="hljs">hexo cleanhexo deploy</code></pre><h3 id="存放全局image的位置（主页背景等）"><a href="#存放全局image的位置（主页背景等）" class="headerlink" title="存放全局image的位置（主页背景等）"></a>存放全局image的位置（主页背景等）</h3><pre><code class="hljs">C:\Users\liu\my_blog\public\img</code></pre><h3 id="将Hexo从C盘迁移到D盘"><a href="#将Hexo从C盘迁移到D盘" class="headerlink" title="将Hexo从C盘迁移到D盘"></a>将Hexo从C盘迁移到D盘</h3><pre><code class="hljs">d:cd D:\my_blog</code></pre><h3 id="如果遇到问题-可通过查询Hexo官网以及Hexo-Fluid进行查找。"><a href="#如果遇到问题-可通过查询Hexo官网以及Hexo-Fluid进行查找。" class="headerlink" title="如果遇到问题, 可通过查询Hexo官网以及Hexo Fluid进行查找。"></a>如果遇到问题, 可通过查询<a href="https://hexo.io/zh-cn/docs/">Hexo官网</a>以及<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">Hexo Fluid</a>进行查找。</h3><h3 id="上标下标书写方式"><a href="#上标下标书写方式" class="headerlink" title="上标下标书写方式"></a>上标下标书写方式</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">H<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span>O  CO<span class="hljs-tag">&lt;<span class="hljs-name">sub</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">sub</span>&gt;</span><br>爆米<span class="hljs-tag">&lt;<span class="hljs-name">sup</span>&gt;</span>TM<span class="hljs-tag">&lt;/<span class="hljs-name">sup</span>&gt;</span><br></code></pre></td></tr></table></figure><p>H<sub>2</sub>O  CO<sub>2</sub><br>爆米<sup>TM</sup></p>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信无关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于hexo和github page搭建博客</title>
    <link href="/2023/05/17/blog-build-remark/"/>
    <url>/2023/05/17/blog-build-remark/</url>
    
    <content type="html"><![CDATA[<p>本文是基于hexo和github page搭建博客的安装指南，主要介绍了基于Scoop对win10系统的软件进行管理，hexo的安装与Hexo Fluid主题配置。</p><span id="more"></span><h1 id="使用github-page搭建blog"><a href="#使用github-page搭建blog" class="headerlink" title="使用github page搭建blog"></a>使用github page搭建blog</h1><h2 id="1-基于Windows10系统，使用Scoop进行软件安装与管理-Scoop"><a href="#1-基于Windows10系统，使用Scoop进行软件安装与管理-Scoop" class="headerlink" title="1 基于Windows10系统，使用Scoop进行软件安装与管理 Scoop"></a>1 基于Windows10系统，使用Scoop进行软件安装与管理 <a href="https://sspai.com/post/52496">Scoop</a></h2><p>在 PowerShell 中输入下面内容，保证允许本地脚本的执行：</p><pre><code class="hljs">set-executionpolicy remotesigned -scope currentuser</code></pre><p>然后执行下面的命令安装 Scoop：</p><pre><code class="hljs">iex (new-object net.webclient).downloadstring(&#39;https://get.scoop.sh&#39;)</code></pre><p>静待脚本执行完成就可以了，安装成功后，让我们尝试一下：</p><pre><code class="hljs">scoop help</code></pre><p>整体搭建流程基于<a href="https://xie.infoq.cn/article/ac51ce1f6e9434779c35cbb6c">教程</a></p><pre><code class="hljs"># 安装Gitscoop install git # 安装 nvmscoop install nvm # 查看可用的 NodeJS 版本，这里建议使用 LTS 版本nvm list available # 安装 NodeJS，我这里安装的是最新 LTS 版本 18.16.0nvm install 18.16.0 #先使用 scoop 安装 sudo 这个工具scoop install sudo# NodeJS 版本使用 18.16.0，注意这里需要管理员权限sudo nvm use 18.16.0 </code></pre><h2 id="2-安装Hexo"><a href="#2-安装Hexo" class="headerlink" title="2. 安装Hexo"></a>2. 安装<a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85-Hexo">Hexo</a></h2><pre><code class="hljs">#一键安装Hexo npm install -g hexo-cli#创建项目并初始化hexo init my_blogcd my_blognpm install#3. 生成网页文件 &amp;本地启动hexo generate # 生成页面，此命令可以简写为 `hexo g`hexo server # 本地启动，可简写为 `hexo s`</code></pre><h2 id="3-修改Hexo主题为fluid"><a href="#3-修改Hexo主题为fluid" class="headerlink" title="3.修改Hexo主题为fluid"></a>3.修改Hexo主题为<a href="https://github.com/fluid-dev/hexo-theme-fluid">fluid</a></h2><pre><code class="hljs">#在博客根路径下（C:\Users\liu\my_blog）将git上的_config.yml文件复制过去并重命名为_config.fluid.yml#对根目录的_config.yml文件进行如下修改：heme: fluid  # 指定主题language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</code></pre><h2 id="4-创建【关于页】"><a href="#4-创建【关于页】" class="headerlink" title="4.创建【关于页】"></a>4.创建【关于页】</h2><p>hexo的<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%BD%92%E6%A1%A3%E9%A1%B5">用户手册</a></p><pre><code class="hljs">hexo new page about</code></pre><p>创建成功后修改 &#x2F;source&#x2F;about&#x2F;index.md，添加 layout 属性。修改后的文件示例如下：<br>    —<br>    title: 标题<br>    layout: about<br>    —<br>    这里写关于页的正文，支持 Markdown, HTML</p><p><strong>注意</strong>：在对关于页进行修改后，需要重新启动hexo</p><pre><code class="hljs">hexo cleanhexo ghexo s</code></pre><h2 id="5-创建文章"><a href="#5-创建文章" class="headerlink" title="5.创建文章"></a>5.创建文章</h2><p>修改 _config.yml 文件。这项配置是为了在生成文章的同时，生成一个同名的资源目录用于存放图片等资源文件。</p><pre><code class="hljs">#将第43行的false改为truepost_asset_folder: true</code></pre><p>创建文件名为 blog_build_remark 文章。<br>    hexo new post blog_build_remark</p><h1 id="发布-GitHub-Pages"><a href="#发布-GitHub-Pages" class="headerlink" title="发布 GitHub Pages"></a>发布 GitHub Pages</h1><p>安装 hexo-deployer-git</p><pre><code class="hljs">npm install hexo-deployer-git --save</code></pre><p>修改站点配置</p><pre><code class="hljs">deploy:    type: git    repo: https://github.com/XUAN-98-L/XUAN-98-L.github.io</code></pre><p>默认会将数据推送到github的master branch,可以直接通过链接进行访问 <a href="https://xuan-98-l.github.io/">https://xuan-98-l.github.io/</a></p><p>设置完成后使用命令进行推送(使用cmd)<br>    hexo clean<br>    hexo deploy</p>]]></content>
    
    
    <categories>
      
      <category>软件算法</category>
      
      <category>生信无关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人成长</tag>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
